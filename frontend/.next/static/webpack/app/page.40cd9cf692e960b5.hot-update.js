"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/layout/RubiksCube.tsx":
/*!**********************************************!*\
  !*** ./src/components/layout/RubiksCube.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RubiksCube: function() { return /* binding */ RubiksCube; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_async_to_generator.js\");\n/* harmony import */ var _swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* __next_internal_client_entry_do_not_use__ RubiksCube auto */ \n\n\nvar _s = $RefreshSig$();\n\n\nfunction RubiksCube() {\n    _s();\n    var containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if ( false || !containerRef.current) return;\n        var scene, camera, renderer, cube, animationId;\n        var floor, floorGeometry;\n        var mouse = {\n            x: 0,\n            y: 0\n        };\n        var raycaster, mouseVector;\n        var particles, particleSystem;\n        var trailPositions = [];\n        // Physics variables - free-falling cube\n        var velocity = {\n            x: 0,\n            y: 0,\n            z: 0\n        } // Will start falling immediately\n        ;\n        var gravity = -0.0005 // Gravity for natural fall\n        ;\n        var bounce = 0.7 // Bouncy\n        ;\n        var friction = 0.98 // Friction to help cube settle\n        ;\n        var bounds = {\n            x: 12,\n            y: 12,\n            z: 8\n        } // Movement bounds\n        ;\n        var defaultPosition = {\n            x: 8,\n            y: 4,\n            z: 0\n        } // Default starting position (floating above floor)\n        ;\n        var ripples = [];\n        var lastClickTime = 0;\n        var lastRippleTime = 0;\n        var gsapRef = null;\n        var floorMaterial = null;\n        var isReturningToPosition = false // Track if cube is returning to default position\n        ;\n        var returnStartTime = 0;\n        // Circuit board wave parameters\n        var rippleParams = {\n            maxRadius: 10.0,\n            expansionSpeed: 2.0,\n            waveHeight: 0.08,\n            ringWidth: 0.35,\n            emissiveGain: 0.3,\n            highlightGain: 0.4,\n            gridScale: 0.5,\n            traceBoost: 0.5,\n            afterglowDecay: 0.94,\n            noiseScale: 3.0,\n            noiseScrollSpeed: 1.2\n        };\n        var init = function() {\n            var _ref = (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_2__._)(function() {\n                var _containerRef_current, container, cw, ch, width, height, offsets, gap, index, x, y, z, geometry, isTextured, surfaceType, material, cubelet, edges, line, hitSphereGeometry, hitSphereMaterial, hitSphere, floorSize, floorSegments, ambientLight, directionalLight1, directionalLight2, pointLight1, pointLight2, rimLight1, loadGSAP, e, pulseFloorGlow, rimLight2, particleCount, particleGeometry, positions, colors, sizes, i, particleMaterial, createRipple, updateFloorRipples, onMouseMove, onMouseClick, createParticleBurst, animate, handleResize;\n                return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            // Create scene\n                            scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();\n                            // Create camera (positioned to show cube near title on right side)\n                            container = containerRef.current;\n                            cw = (container === null || container === void 0 ? void 0 : container.clientWidth) || 0;\n                            ch = (container === null || container === void 0 ? void 0 : container.clientHeight) || 0;\n                            width = cw > 10 ? cw :  true ? window.innerWidth : 0;\n                            height = ch > 10 ? ch :  true ? window.innerHeight : 0;\n                            camera = new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(65, width / height, 0.1, 1000);\n                            camera.position.set(8, 2, 20);\n                            camera.lookAt(8, 0, 0);\n                            // Setup raycaster for mouse interaction\n                            raycaster = new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster();\n                            mouseVector = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2();\n                            // Create renderer\n                            renderer = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer({\n                                antialias: true,\n                                alpha: true\n                            });\n                            if (true) {\n                                renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n                            }\n                            renderer.setSize(width, height);\n                            renderer.shadowMap.enabled = true;\n                            (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.appendChild(renderer.domElement);\n                            // Create Rubik's cube group\n                            cube = new three__WEBPACK_IMPORTED_MODULE_4__.Group();\n                            // Create 3x3x3 grid of cubelets\n                            offsets = [\n                                -1,\n                                0,\n                                1\n                            ];\n                            gap = 0.1;\n                            index = 0;\n                            for(x = 0; x < 3; x++){\n                                for(y = 0; y < 3; y++){\n                                    for(z = 0; z < 3; z++){\n                                        geometry = new three__WEBPACK_IMPORTED_MODULE_4__.BoxGeometry(0.9, 0.9, 0.9);\n                                        // Create dark materials\n                                        isTextured = index % 4 === 0;\n                                        surfaceType = Math.random();\n                                        material = void 0;\n                                        if (surfaceType < 0.25 && isTextured) {\n                                            material = new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                                                color: 0x2a2a2a,\n                                                metalness: 0.5,\n                                                roughness: 0.3,\n                                                transparent: false,\n                                                opacity: 1.0\n                                            });\n                                        } else if (surfaceType < 0.5) {\n                                            material = new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                                                color: 0x1a1a1a,\n                                                metalness: 0.5,\n                                                roughness: 0.3,\n                                                transparent: false,\n                                                opacity: 1.0\n                                            });\n                                        } else if (surfaceType < 0.75) {\n                                            material = new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                                                color: 0x333333,\n                                                metalness: 0.5,\n                                                roughness: 0.3,\n                                                transparent: false,\n                                                opacity: 1.0\n                                            });\n                                        } else {\n                                            material = new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                                                color: 0x252525,\n                                                metalness: 0.5,\n                                                roughness: 0.3,\n                                                transparent: false,\n                                                opacity: 1.0\n                                            });\n                                        }\n                                        cubelet = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(geometry, material);\n                                        cubelet.position.set(offsets[x] * (0.9 + gap), offsets[y] * (0.9 + gap), offsets[z] * (0.9 + gap));\n                                        cubelet.castShadow = true;\n                                        cubelet.receiveShadow = true;\n                                        // Add wireframe edges\n                                        edges = new three__WEBPACK_IMPORTED_MODULE_4__.EdgesGeometry(geometry);\n                                        line = new three__WEBPACK_IMPORTED_MODULE_4__.LineSegments(edges, new three__WEBPACK_IMPORTED_MODULE_4__.LineBasicMaterial({\n                                            color: 0x4b5563,\n                                            transparent: true,\n                                            opacity: 0.4\n                                        }));\n                                        cubelet.add(line);\n                                        cube.add(cubelet);\n                                        index++;\n                                    }\n                                }\n                            }\n                            // Position cube at default floating position - will start falling immediately\n                            cube.position.set(defaultPosition.x, defaultPosition.y, defaultPosition.z);\n                            scene.add(cube);\n                            // Ensure cube renders after grid to avoid \"submerging\" visuals\n                            cube.traverse(function(o) {\n                                o.renderOrder = 1;\n                            });\n                            // Add invisible bounding sphere for easier clicking\n                            hitSphereGeometry = new three__WEBPACK_IMPORTED_MODULE_4__.SphereGeometry(2.0, 16, 16);\n                            hitSphereMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.MeshBasicMaterial({\n                                visible: false,\n                                transparent: true,\n                                opacity: 0\n                            });\n                            hitSphere = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(hitSphereGeometry, hitSphereMaterial);\n                            hitSphere.name = \"hitTarget\";\n                            cube.add(hitSphere);\n                            console.log(\"\\uD83C\\uDFB2 Cube initialized at position:\", defaultPosition, \"- free-falling enabled\");\n                            // Create floor with circuit board shader\n                            floorSize = 100;\n                            floorSegments = 300;\n                            floorGeometry = new three__WEBPACK_IMPORTED_MODULE_4__.PlaneGeometry(floorSize, floorSize, floorSegments, floorSegments);\n                            floorGeometry.rotateX(-Math.PI / 2);\n                            // Custom shader material for circuit board effect\n                            floorMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.ShaderMaterial({\n                                uniforms: {\n                                    time: {\n                                        value: 0\n                                    },\n                                    gridScale: {\n                                        value: rippleParams.gridScale\n                                    },\n                                    baseColor: {\n                                        value: new three__WEBPACK_IMPORTED_MODULE_4__.Color(0x0d1117)\n                                    },\n                                    gridColor: {\n                                        value: new three__WEBPACK_IMPORTED_MODULE_4__.Color(0x2a3f5f)\n                                    },\n                                    glowColor: {\n                                        value: new three__WEBPACK_IMPORTED_MODULE_4__.Color(0x4a9eff)\n                                    },\n                                    ripplePositions: {\n                                        value: [\n                                            new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(),\n                                            new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(),\n                                            new three__WEBPACK_IMPORTED_MODULE_4__.Vector3()\n                                        ]\n                                    },\n                                    rippleRadii: {\n                                        value: [\n                                            0,\n                                            0,\n                                            0\n                                        ]\n                                    },\n                                    rippleStrengths: {\n                                        value: [\n                                            0,\n                                            0,\n                                            0\n                                        ]\n                                    }\n                                },\n                                vertexShader: \"\\n          varying vec2 vUv;\\n          varying vec3 vWorldPosition;\\n\\n          void main() {\\n            vUv = uv;\\n            vec4 worldPosition = modelMatrix * vec4(position, 1.0);\\n            vWorldPosition = worldPosition.xyz;\\n            gl_Position = projectionMatrix * viewMatrix * worldPosition;\\n          }\\n        \",\n                                fragmentShader: \"\\n          uniform float time;\\n          uniform float gridScale;\\n          uniform vec3 baseColor;\\n          uniform vec3 gridColor;\\n          uniform vec3 glowColor;\\n          uniform vec3 ripplePositions[3];\\n          uniform float rippleRadii[3];\\n          uniform float rippleStrengths[3];\\n\\n          varying vec2 vUv;\\n          varying vec3 vWorldPosition;\\n\\n          // Circuit board grid pattern\\n          float gridPattern(vec2 pos) {\\n            vec2 grid = abs(fract(pos / gridScale - 0.5) - 0.5);\\n            float line = min(grid.x, grid.y);\\n            return smoothstep(0.02, 0.0, line);\\n          }\\n\\n          // Circuit trace pattern (more complex)\\n          float tracePattern(vec2 pos) {\\n            vec2 p = pos / gridScale;\\n\\n            // Horizontal and vertical traces\\n            float h = step(0.85, fract(p.y));\\n            float v = step(0.85, fract(p.x));\\n\\n            // Diagonal traces (less frequent)\\n            float d1 = step(0.92, fract((p.x + p.y) * 0.5));\\n            float d2 = step(0.92, fract((p.x - p.y) * 0.5));\\n\\n            return max(max(h, v), max(d1, d2));\\n          }\\n\\n          void main() {\\n            vec2 pos = vWorldPosition.xz;\\n\\n            // Base circuit board pattern\\n            float grid = gridPattern(pos);\\n            float traces = tracePattern(pos);\\n            float pattern = max(grid * 0.4, traces);\\n\\n            // Calculate ripple activation\\n            float activation = 0.0;\\n            for(int i = 0; i < 3; i++) {\\n              if(rippleStrengths[i] > 0.0) {\\n                float dist = distance(vWorldPosition.xz, ripplePositions[i].xz);\\n                float rippleEdge = abs(dist - rippleRadii[i]);\\n\\n                // Activate traces near the ripple edge\\n                if(rippleEdge < 0.8) {\\n                  float edgeFactor = 1.0 - (rippleEdge / 0.8);\\n                  activation = max(activation, edgeFactor * rippleStrengths[i]);\\n                }\\n\\n                // Also activate traces that have been passed by the wave (afterglow)\\n                if(dist < rippleRadii[i]) {\\n                  float afterglow = (1.0 - dist / rippleRadii[i]) * 0.15 * rippleStrengths[i];\\n                  activation = max(activation, afterglow);\\n                }\\n              }\\n            }\\n\\n            // Mix colors based on activation\\n            vec3 basePattern = mix(baseColor, gridColor, pattern);\\n            vec3 finalColor = mix(basePattern, glowColor, activation * pattern);\\n\\n            // Make floor mostly transparent but show circuit pattern\\n            float alpha = pattern * 0.2 + activation * pattern * 0.7;\\n\\n            gl_FragColor = vec4(finalColor, alpha);\\n          }\\n        \",\n                                transparent: true,\n                                side: three__WEBPACK_IMPORTED_MODULE_4__.DoubleSide\n                            });\n                            floor = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(floorGeometry, floorMaterial);\n                            floor.position.set(8, -4, 0);\n                            floor.receiveShadow = false;\n                            scene.add(floor);\n                            console.log(\"✅ Circuit board floor created with shader\");\n                            // Darker, more atmospheric lighting for circuit board aesthetic\n                            ambientLight = new three__WEBPACK_IMPORTED_MODULE_4__.AmbientLight(0x2a2f3a, 0.5);\n                            scene.add(ambientLight);\n                            directionalLight1 = new three__WEBPACK_IMPORTED_MODULE_4__.DirectionalLight(0xffffff, 0.5);\n                            directionalLight1.position.set(10, 10, 10);\n                            scene.add(directionalLight1);\n                            directionalLight2 = new three__WEBPACK_IMPORTED_MODULE_4__.DirectionalLight(0x404050, 0.2);\n                            directionalLight2.position.set(-10, -10, -10);\n                            scene.add(directionalLight2);\n                            // Subtle blue accent lights for circuit board glow\n                            pointLight1 = new three__WEBPACK_IMPORTED_MODULE_4__.PointLight(0x0066aa, 1.0, 100);\n                            pointLight1.position.set(8, 5, 10);\n                            scene.add(pointLight1);\n                            pointLight2 = new three__WEBPACK_IMPORTED_MODULE_4__.PointLight(0x004488, 0.8, 100);\n                            pointLight2.position.set(8, -3, 10);\n                            scene.add(pointLight2);\n                            // Add rim lights for dramatic effect\n                            rimLight1 = new three__WEBPACK_IMPORTED_MODULE_4__.PointLight(0x003366, 0.4, 100);\n                            rimLight1.position.set(0, 10, -10);\n                            // GSAP loader and intro animations\n                            loadGSAP = function() {\n                                return new Promise(function(resolve, reject) {\n                                    if ( true && window.gsap) return resolve(window.gsap);\n                                    var s = document.createElement(\"script\");\n                                    s.src = \"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js\";\n                                    s.async = true;\n                                    s.onload = function() {\n                                        return resolve(window.gsap);\n                                    };\n                                    s.onerror = reject;\n                                    document.head.appendChild(s);\n                                });\n                            };\n                            _state.label = 1;\n                        case 1:\n                            _state.trys.push([\n                                1,\n                                3,\n                                ,\n                                4\n                            ]);\n                            return [\n                                4,\n                                loadGSAP()\n                            ];\n                        case 2:\n                            gsapRef = _state.sent();\n                            // Smooth camera intro\n                            gsapRef.fromTo(camera.position, {\n                                z: camera.position.z + 4,\n                                y: camera.position.y - 0.8\n                            }, {\n                                z: camera.position.z,\n                                y: camera.position.y,\n                                duration: 1.2,\n                                ease: \"power2.out\"\n                            });\n                            return [\n                                3,\n                                4\n                            ];\n                        case 3:\n                            e = _state.sent();\n                            return [\n                                3,\n                                4\n                            ];\n                        case 4:\n                            pulseFloorGlow = function(strength) {\n                                if (!gsapRef || !floorMaterial) return;\n                                var targetIntensity = Math.min(0.8, 0.3 + strength * 1.2);\n                                // Pulse the emissive intensity to reveal circuit pattern\n                                gsapRef.to(floorMaterial, {\n                                    emissiveIntensity: targetIntensity,\n                                    duration: 0.15,\n                                    ease: \"power2.out\",\n                                    yoyo: true,\n                                    repeat: 1\n                                });\n                            };\n                            scene.add(rimLight1);\n                            rimLight2 = new three__WEBPACK_IMPORTED_MODULE_4__.PointLight(0x004488, 0.3, 100);\n                            rimLight2.position.set(10, -5, 0);\n                            scene.add(rimLight2);\n                            // Create particle system for impact effects\n                            particleCount = 500;\n                            particleGeometry = new three__WEBPACK_IMPORTED_MODULE_4__.BufferGeometry();\n                            positions = new Float32Array(particleCount * 3);\n                            colors = new Float32Array(particleCount * 3);\n                            sizes = new Float32Array(particleCount);\n                            for(i = 0; i < particleCount; i++){\n                                positions[i * 3] = 0;\n                                positions[i * 3 + 1] = 0;\n                                positions[i * 3 + 2] = 0;\n                                colors[i * 3] = 0.2;\n                                colors[i * 3 + 1] = 0.5;\n                                colors[i * 3 + 2] = 1.0;\n                                sizes[i] = Math.random() * 0.1 + 0.05;\n                            }\n                            particleGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_4__.BufferAttribute(positions, 3));\n                            particleGeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_4__.BufferAttribute(colors, 3));\n                            particleGeometry.setAttribute(\"size\", new three__WEBPACK_IMPORTED_MODULE_4__.BufferAttribute(sizes, 1));\n                            particleMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.PointsMaterial({\n                                size: 0.1,\n                                transparent: true,\n                                opacity: 0.6,\n                                vertexColors: true,\n                                blending: three__WEBPACK_IMPORTED_MODULE_4__.AdditiveBlending,\n                                sizeAttenuation: true\n                            });\n                            particleSystem = new three__WEBPACK_IMPORTED_MODULE_4__.Points(particleGeometry, particleMaterial);\n                            scene.add(particleSystem);\n                            createRipple = function(x, z, strength) {\n                                var now = typeof performance !== \"undefined\" ? performance.now() : Date.now();\n                                if (now - lastRippleTime < 120) {\n                                    return; // throttle to prevent haywire on rapid bounces\n                                }\n                                lastRippleTime = now;\n                                // Create ultra-subtle realistic wave ripple\n                                var s = Math.min(1.0, 0.4 + strength * 0.6);\n                                // Convert floor-local coordinates to world coordinates\n                                var worldX = x + floor.position.x;\n                                var worldZ = z;\n                                var worldY = floor.position.y;\n                                // Create realistic wave ripple - very thin, barely visible\n                                var rings = [];\n                                var particles = [];\n                                // Darker, more visible wave crest\n                                var waveGeo = new three__WEBPACK_IMPORTED_MODULE_4__.TorusGeometry(0.5, 0.035, 8, 64) // Slightly thicker\n                                ;\n                                var waveMat = new three__WEBPACK_IMPORTED_MODULE_4__.MeshBasicMaterial({\n                                    color: 0x3a6ea5,\n                                    transparent: true,\n                                    opacity: 0.25,\n                                    side: three__WEBPACK_IMPORTED_MODULE_4__.DoubleSide,\n                                    blending: three__WEBPACK_IMPORTED_MODULE_4__.AdditiveBlending\n                                });\n                                var wave = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(waveGeo, waveMat);\n                                wave.rotation.x = Math.PI / 2;\n                                wave.position.set(worldX, worldY, worldZ);\n                                scene.add(wave);\n                                rings.push({\n                                    mesh: wave,\n                                    type: \"main\",\n                                    initialY: worldY\n                                });\n                                ripples.push({\n                                    x: x,\n                                    z: z,\n                                    time: 0,\n                                    strength: s,\n                                    rings: rings,\n                                    particles: particles\n                                });\n                                // Limit to 3 concurrent waves\n                                if (ripples.length > 3) {\n                                    var removed = ripples.shift();\n                                    if (removed) {\n                                        removed.rings.forEach(function(r) {\n                                            return scene.remove(r.mesh);\n                                        });\n                                        removed.particles.forEach(function(p) {\n                                            return scene.remove(p.system);\n                                        });\n                                    }\n                                }\n                                console.log(\"\\uD83C\\uDF0A Ultra-subtle wave ripple created at:\", worldX, worldY, worldZ);\n                            };\n                            // Function to update circuit board wave effect\n                            updateFloorRipples = function() {\n                                // Update shader uniforms with ripple data\n                                var positions = [];\n                                var radii = [];\n                                var strengths = [];\n                                ripples = ripples.filter(function(ripple, index) {\n                                    ripple.time += 0.016 // ~60fps\n                                    ;\n                                    // Slow expansion\n                                    var expansionSpeed = rippleParams.expansionSpeed // 2.0 units/sec\n                                    ;\n                                    var maxRadius = rippleParams.maxRadius // 10.0 units\n                                    ;\n                                    var waveHeight = rippleParams.waveHeight // 0.08 units vertical\n                                    ;\n                                    var currentRadius = ripple.time * expansionSpeed;\n                                    // 5 second total duration - very slow\n                                    var totalDuration = 5.0;\n                                    var progress = ripple.time / totalDuration;\n                                    // Very smooth ease-out for gentle expansion\n                                    var easeOut = 1 - Math.pow(1 - Math.min(progress, 1), 2);\n                                    // Calculate strength for shader\n                                    var strength = 0;\n                                    if (progress < 0.3) {\n                                        strength = progress / 0.3 * 0.8;\n                                    } else if (progress < 0.6) {\n                                        strength = 0.8;\n                                    } else {\n                                        strength = 0.8 * (1 - (progress - 0.6) / 0.4);\n                                    }\n                                    // Store ripple data for shader (up to 3 ripples)\n                                    if (index < 3) {\n                                        var worldX = ripple.x + floor.position.x;\n                                        var worldZ = ripple.z;\n                                        positions.push(new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(worldX, floor.position.y, worldZ));\n                                        radii.push(currentRadius * easeOut);\n                                        strengths.push(strength);\n                                    }\n                                    // Animate the wave ring\n                                    ripple.rings.forEach(function(ringObj) {\n                                        var ring = ringObj.mesh;\n                                        var initialY = ringObj.initialY;\n                                        // Scale outward slowly\n                                        var scale = 1 + currentRadius * easeOut * 1.0;\n                                        ring.scale.set(scale, scale, scale);\n                                        // Subtle vertical wave motion\n                                        var heightOffset = 0;\n                                        if (progress < 0.35) {\n                                            heightOffset = progress / 0.35 * waveHeight;\n                                        } else if (progress < 0.55) {\n                                            heightOffset = waveHeight;\n                                        } else {\n                                            heightOffset = waveHeight * (1 - (progress - 0.55) / 0.45);\n                                        }\n                                        ring.position.y = initialY + heightOffset;\n                                        // Opacity animation\n                                        var opacity = 0;\n                                        if (progress < 0.3) {\n                                            opacity = progress / 0.3 * 0.25;\n                                        } else if (progress < 0.6) {\n                                            opacity = 0.25;\n                                        } else {\n                                            opacity = 0.25 * (1 - (progress - 0.6) / 0.4);\n                                        }\n                                        ring.material.opacity = Math.max(0, opacity);\n                                    });\n                                    // Remove when complete\n                                    if (ripple.time >= totalDuration || currentRadius > maxRadius) {\n                                        ripple.rings.forEach(function(r) {\n                                            return scene.remove(r.mesh);\n                                        });\n                                        ripple.particles.forEach(function(p) {\n                                            return scene.remove(p.system);\n                                        });\n                                        return false;\n                                    }\n                                    return true;\n                                });\n                                // Update floor shader uniforms\n                                if (floor && floor.material && floor.material.uniforms) {\n                                    // Pad arrays to length 3\n                                    while(positions.length < 3)positions.push(new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0));\n                                    while(radii.length < 3)radii.push(0);\n                                    while(strengths.length < 3)strengths.push(0);\n                                    floor.material.uniforms.ripplePositions.value = positions;\n                                    floor.material.uniforms.rippleRadii.value = radii;\n                                    floor.material.uniforms.rippleStrengths.value = strengths;\n                                }\n                            };\n                            // Mouse interaction handlers\n                            onMouseMove = function(event) {\n                                var rect = renderer.domElement.getBoundingClientRect();\n                                mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n                                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n                                // Check if hovering over cube\n                                mouseVector.x = mouse.x;\n                                mouseVector.y = mouse.y;\n                                raycaster.setFromCamera(mouseVector, camera);\n                                var intersects = raycaster.intersectObject(cube, true);\n                                // Change cursor when hovering\n                                if (intersects.length > 0) {\n                                    renderer.domElement.style.cursor = \"pointer\";\n                                } else {\n                                    renderer.domElement.style.cursor = \"grab\";\n                                }\n                            };\n                            onMouseClick = function(event) {\n                                var currentTime = Date.now();\n                                // Reduced debounce time for better responsiveness\n                                if (currentTime - lastClickTime < 200) {\n                                    return;\n                                }\n                                lastClickTime = currentTime;\n                                // Calculate mouse position relative to canvas\n                                var rect = renderer.domElement.getBoundingClientRect();\n                                mouseVector.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n                                mouseVector.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n                                raycaster.setFromCamera(mouseVector, camera);\n                                // Check intersection with cube and all its children (including invisible bounding sphere)\n                                var intersects = raycaster.intersectObject(cube, true);\n                                console.log(\"\\uD83C\\uDFAF Click detected! Intersects:\", intersects.length, \"Cube position:\", cube.position);\n                                // ONLY trigger if clicking directly on the cube\n                                if (intersects.length > 0) {\n                                    console.log(\"✅ HIT! Cube clicked at:\", intersects[0].point);\n                                    // Cancel any ongoing return animation\n                                    isReturningToPosition = false;\n                                    returnStartTime = 0;\n                                    // Bounce the cube with a quick impulse\n                                    var direction = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n                                    var clickPoint = intersects[0].point;\n                                    direction.subVectors(cube.position, clickPoint).normalize();\n                                    // Apply bounce force (REPLACE velocity, not add)\n                                    velocity.x = direction.x * 0.15;\n                                    velocity.y = Math.abs(direction.y) * 0.12 + 0.12;\n                                    velocity.z = direction.z * 0.15;\n                                    // Particle burst on click\n                                    createParticleBurst(cube.position.x, cube.position.y, cube.position.z, 0.8);\n                                    // Schedule return-to-position after 1.5 seconds\n                                    returnStartTime = currentTime + 1500;\n                                    console.log(\"\\uD83D\\uDE80 Cube bounced! Velocity:\", velocity);\n                                } else {\n                                    console.log(\"❌ MISS - Click did not hit cube\");\n                                }\n                            };\n                            // Add event listeners\n                            renderer.domElement.addEventListener(\"mousemove\", onMouseMove);\n                            renderer.domElement.addEventListener(\"click\", onMouseClick);\n                            // Function to create particle burst on impact\n                            createParticleBurst = function(x, y, z, strength) {\n                                var positions = particleGeometry.attributes.position.array;\n                                var particleCount = positions.length / 3;\n                                var burstCount = Math.min(50, Math.floor(strength * 100));\n                                for(var i = 0; i < burstCount; i++){\n                                    var idx = i % particleCount * 3;\n                                    positions[idx] = x + (Math.random() - 0.5) * 0.5;\n                                    positions[idx + 1] = y + (Math.random() - 0.5) * 0.5;\n                                    positions[idx + 2] = z + (Math.random() - 0.5) * 0.5;\n                                }\n                                particleGeometry.attributes.position.needsUpdate = true;\n                            };\n                            // Animation loop with enhanced physics\n                            animate = function() {\n                                animationId = requestAnimationFrame(animate);\n                                // Check if it's time to return to position\n                                var currentTime = Date.now();\n                                if (!isReturningToPosition && returnStartTime > 0 && currentTime >= returnStartTime) {\n                                    isReturningToPosition = true;\n                                    console.log(\"\\uD83D\\uDD04 Starting return to default position\");\n                                }\n                                // Return to position logic (apply gentle force towards default position)\n                                if (isReturningToPosition) {\n                                    var dx = defaultPosition.x - cube.position.x;\n                                    var dy = defaultPosition.y - cube.position.y;\n                                    var dz = defaultPosition.z - cube.position.z;\n                                    var distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                                    if (distance < 0.2) {\n                                        // Close enough - snap to position and stop\n                                        cube.position.set(defaultPosition.x, defaultPosition.y, defaultPosition.z);\n                                        velocity.x = 0;\n                                        velocity.y = 0;\n                                        velocity.z = 0;\n                                        isReturningToPosition = false;\n                                        returnStartTime = 0;\n                                        console.log(\"✅ Cube returned to default position\");\n                                    } else {\n                                        // Apply gentle force towards default position (instead of setting velocity directly)\n                                        var pullStrength = 0.002;\n                                        velocity.x += dx * pullStrength;\n                                        velocity.y += dy * pullStrength;\n                                        velocity.z += dz * pullStrength;\n                                        // Dampen velocity while returning\n                                        velocity.x *= 0.95;\n                                        velocity.y *= 0.95;\n                                        velocity.z *= 0.95;\n                                    }\n                                } else {\n                                    // Apply gravity when not returning to position\n                                    velocity.y += gravity;\n                                }\n                                // Update position (keep cube centered around x=8)\n                                var newX = cube.position.x + velocity.x;\n                                var newY = cube.position.y + velocity.y;\n                                var newZ = cube.position.z + velocity.z;\n                                cube.position.x = newX;\n                                cube.position.y = newY;\n                                cube.position.z = newZ;\n                                // Dynamic rotation based on velocity (more realistic physics)\n                                var speed = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2) + Math.pow(velocity.z, 2));\n                                cube.rotation.x += 0.006 + speed * 0.5;\n                                cube.rotation.y += 0.008 + speed * 0.6;\n                                cube.rotation.z += 0.005 + speed * 0.4;\n                                // Update particle positions (fade out)\n                                var positions = particleGeometry.attributes.position.array;\n                                for(var i = 0; i < positions.length; i += 3){\n                                    positions[i + 1] -= 0.02 // Particles fall\n                                    ;\n                                    if (positions[i + 1] < -15) {\n                                        positions[i + 1] = 0;\n                                    }\n                                }\n                                particleGeometry.attributes.position.needsUpdate = true;\n                                // Check floor collision\n                                // Cube is 3 units tall, so radius is 1.5. Floor is at y=-4\n                                // Cube bottom = cube.position.y - 1.5\n                                var halfSize = 1.5;\n                                var xA = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 0, 0).applyQuaternion(cube.quaternion);\n                                var yA = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0).applyQuaternion(cube.quaternion);\n                                var zA = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 1).applyQuaternion(cube.quaternion);\n                                var vertExtent = halfSize * (Math.abs(xA.y) + Math.abs(yA.y) + Math.abs(zA.y));\n                                var cubeBottom = cube.position.y - vertExtent;\n                                var floorY = -4;\n                                if (cubeBottom <= floorY) {\n                                    cube.position.y = floorY + vertExtent // Keep cube sitting on floor (orientation-aware)\n                                    ;\n                                    velocity.y = -velocity.y * bounce;\n                                    velocity.x *= friction // Apply friction\n                                    ;\n                                    velocity.z *= friction;\n                                    // Create ripple and particle burst on floor impact (adjust for floor offset)\n                                    if (Math.abs(velocity.y) > 0.003) {\n                                        // Compute precise contact point (world-space) by sampling the lowest cube vertex\n                                        var hs = halfSize;\n                                        var minY = Infinity;\n                                        var sumX = 0, sumZ = 0, count = 0;\n                                        var ox = [\n                                            hs,\n                                            hs,\n                                            hs,\n                                            hs,\n                                            -hs,\n                                            -hs,\n                                            -hs,\n                                            -hs\n                                        ];\n                                        var oy = [\n                                            hs,\n                                            hs,\n                                            -hs,\n                                            -hs,\n                                            hs,\n                                            hs,\n                                            -hs,\n                                            -hs\n                                        ];\n                                        var oz = [\n                                            hs,\n                                            -hs,\n                                            hs,\n                                            -hs,\n                                            hs,\n                                            -hs,\n                                            hs,\n                                            -hs\n                                        ];\n                                        for(var i1 = 0; i1 < 8; i1++){\n                                            var wx = cube.position.x + xA.x * ox[i1] + yA.x * oy[i1] + zA.x * oz[i1];\n                                            var wy = cube.position.y + xA.y * ox[i1] + yA.y * oy[i1] + zA.y * oz[i1];\n                                            var wz = cube.position.z + xA.z * ox[i1] + yA.z * oy[i1] + zA.z * oz[i1];\n                                            if (wy < minY - 1e-6) {\n                                                minY = wy;\n                                                sumX = wx;\n                                                sumZ = wz;\n                                                count = 1;\n                                            } else if (Math.abs(wy - minY) <= 1e-6) {\n                                                sumX += wx;\n                                                sumZ += wz;\n                                                count++;\n                                            }\n                                        }\n                                        var contactXWorld = sumX / count;\n                                        var contactZWorld = sumZ / count;\n                                        createRipple(contactXWorld - floor.position.x, contactZWorld, Math.min(1.2, Math.abs(velocity.y) * 1.2)) // Centered on actual contact point (converted to floor local)\n                                        ;\n                                        createParticleBurst(cube.position.x, cube.position.y, cube.position.z, Math.abs(velocity.y));\n                                        pulseFloorGlow(Math.abs(velocity.y));\n                                    }\n                                    // Settle the cube if velocity is very low\n                                    var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2) + Math.pow(velocity.z, 2));\n                                    if (totalVelocity < 0.005) {\n                                        velocity.x = 0;\n                                        velocity.y = 0;\n                                        velocity.z = 0;\n                                    }\n                                }\n                                // Check ceiling collision (solid ceiling)\n                                var ceilingY = bounds.y;\n                                if (cube.position.y + vertExtent >= ceilingY) {\n                                    cube.position.y = ceilingY - vertExtent;\n                                    velocity.y = -velocity.y * bounce;\n                                    // No ripples on ceiling hits; optional particle burst only\n                                    createParticleBurst(cube.position.x, cube.position.y, cube.position.z, Math.abs(velocity.y) * 0.5);\n                                }\n                                // Check wall collisions (X axis)\n                                var minX = 8 - bounds.x + halfSize;\n                                var maxX = 8 + bounds.x - halfSize;\n                                if (cube.position.x <= minX || cube.position.x >= maxX) {\n                                    cube.position.x = cube.position.x <= minX ? minX : maxX;\n                                    velocity.x = -velocity.x * bounce;\n                                    // No ripples on wall impact; particle burst only\n                                    createParticleBurst(cube.position.x, cube.position.y, cube.position.z, Math.abs(velocity.x) * 0.7);\n                                }\n                                // Check wall collisions (Z axis)\n                                var minZ = -bounds.z + halfSize;\n                                var maxZ = bounds.z - halfSize;\n                                if (cube.position.z <= minZ || cube.position.z >= maxZ) {\n                                    cube.position.z = cube.position.z <= minZ ? minZ : maxZ;\n                                    velocity.z = -velocity.z * bounce;\n                                    // No ripples on wall impact; particle burst only\n                                    createParticleBurst(cube.position.x, cube.position.y, cube.position.z, Math.abs(velocity.z) * 0.7);\n                                }\n                                // Update floor ripples (reveals circuit board)\n                                updateFloorRipples();\n                                renderer.render(scene, camera);\n                            };\n                            animate();\n                            // Handle resize\n                            handleResize = function() {\n                                if (!containerRef.current) return;\n                                var cw = containerRef.current.clientWidth;\n                                var ch = containerRef.current.clientHeight;\n                                var width = cw > 10 ? cw :  true ? window.innerWidth : 0;\n                                var height = ch > 10 ? ch :  true ? window.innerHeight : 0;\n                                camera.aspect = width / height;\n                                camera.updateProjectionMatrix();\n                                renderer.setSize(width, height);\n                            };\n                            window.addEventListener(\"resize\", handleResize);\n                            return [\n                                2,\n                                function() {\n                                    var _containerRef_current;\n                                    window.removeEventListener(\"resize\", handleResize);\n                                    renderer.domElement.removeEventListener(\"mousemove\", onMouseMove);\n                                    renderer.domElement.removeEventListener(\"click\", onMouseClick);\n                                    cancelAnimationFrame(animationId);\n                                    if (renderer && ((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.contains(renderer.domElement))) {\n                                        containerRef.current.removeChild(renderer.domElement);\n                                    }\n                                    renderer === null || renderer === void 0 ? void 0 : renderer.dispose();\n                                }\n                            ];\n                    }\n                });\n            });\n            return function init() {\n                return _ref.apply(this, arguments);\n            };\n        }();\n        init();\n        return function() {\n            if (animationId) cancelAnimationFrame(animationId);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-full h-full\",\n        style: {\n            minHeight: \"100vh\",\n            cursor: \"pointer\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\josel\\\\OneDrive\\\\Desktop\\\\GitHub\\\\apps\\\\frontend\\\\src\\\\components\\\\layout\\\\RubiksCube.tsx\",\n        lineNumber: 822,\n        columnNumber: 5\n    }, this);\n}\n_s(RubiksCube, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = RubiksCube;\nvar _c;\n$RefreshReg$(_c, \"RubiksCube\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xheW91dC9SdWJpa3NDdWJlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUV5QztBQUNYO0FBRXZCLFNBQVNHOztJQUNkLElBQU1DLGVBQWVILDZDQUFNQSxDQUFpQjtJQUU1Q0QsZ0RBQVNBLENBQUM7UUFDUixJQUFJLE1BQWtCLElBQWUsQ0FBQ0ksYUFBYUMsT0FBTyxFQUFFO1FBRTVELElBQUlDLE9BQVlDLFFBQWFDLFVBQWVDLE1BQVdDO1FBQ3ZELElBQUlDLE9BQVlDO1FBQ2hCLElBQUlDLFFBQVE7WUFBRUMsR0FBRztZQUFHQyxHQUFHO1FBQUU7UUFDekIsSUFBSUMsV0FBZ0JDO1FBQ3BCLElBQUlDLFdBQWdCQztRQUNwQixJQUFJQyxpQkFBMkUsRUFBRTtRQUVqRix3Q0FBd0M7UUFDeEMsSUFBSUMsV0FBVztZQUFFUCxHQUFHO1lBQUdDLEdBQUc7WUFBR08sR0FBRztRQUFFLEVBQUcsaUNBQWlDOztRQUN0RSxJQUFJQyxVQUFVLENBQUMsT0FBUSwyQkFBMkI7O1FBQ2xELElBQUlDLFNBQVMsSUFBVSxTQUFTOztRQUNoQyxJQUFJQyxXQUFXLEtBQVEsK0JBQStCOztRQUN0RCxJQUFJQyxTQUFTO1lBQUVaLEdBQUc7WUFBSUMsR0FBRztZQUFJTyxHQUFHO1FBQUUsRUFBRyxrQkFBa0I7O1FBQ3ZELElBQUlLLGtCQUFrQjtZQUFFYixHQUFHO1lBQUdDLEdBQUc7WUFBR08sR0FBRztRQUFFLEVBQUcsbURBQW1EOztRQUMvRixJQUFJTSxVQUEyRyxFQUFFO1FBQ2pILElBQUlDLGdCQUFnQjtRQUNwQixJQUFJQyxpQkFBaUI7UUFDckIsSUFBSUMsVUFBZTtRQUNuQixJQUFJQyxnQkFBcUI7UUFDekIsSUFBSUMsd0JBQXdCLE1BQU8saURBQWlEOztRQUNwRixJQUFJQyxrQkFBa0I7UUFFdEIsZ0NBQWdDO1FBQ2hDLElBQU1DLGVBQWU7WUFDbkJDLFdBQVc7WUFDWEMsZ0JBQWdCO1lB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c3JjL2NvbXBvbmVudHMvbGF5b3V0L1J1Ymlrc0N1YmUudHN4PzMzMDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcblxuZXhwb3J0IGZ1bmN0aW9uIFJ1Ymlrc0N1YmUoKSB7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhY29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgbGV0IHNjZW5lOiBhbnksIGNhbWVyYTogYW55LCByZW5kZXJlcjogYW55LCBjdWJlOiBhbnksIGFuaW1hdGlvbklkOiBudW1iZXJcbiAgICBsZXQgZmxvb3I6IGFueSwgZmxvb3JHZW9tZXRyeTogYW55XG4gICAgbGV0IG1vdXNlID0geyB4OiAwLCB5OiAwIH1cbiAgICBsZXQgcmF5Y2FzdGVyOiBhbnksIG1vdXNlVmVjdG9yOiBhbnlcbiAgICBsZXQgcGFydGljbGVzOiBhbnksIHBhcnRpY2xlU3lzdGVtOiBhbnlcbiAgICBsZXQgdHJhaWxQb3NpdGlvbnM6IEFycmF5PHsgeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlciwgbGlmZTogbnVtYmVyIH0+ID0gW11cblxuICAgIC8vIFBoeXNpY3MgdmFyaWFibGVzIC0gZnJlZS1mYWxsaW5nIGN1YmVcbiAgICBsZXQgdmVsb2NpdHkgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfSAgLy8gV2lsbCBzdGFydCBmYWxsaW5nIGltbWVkaWF0ZWx5XG4gICAgbGV0IGdyYXZpdHkgPSAtMC4wMDA1ICAvLyBHcmF2aXR5IGZvciBuYXR1cmFsIGZhbGxcbiAgICBsZXQgYm91bmNlID0gMC43ICAgICAgIC8vIEJvdW5jeVxuICAgIGxldCBmcmljdGlvbiA9IDAuOTggICAgLy8gRnJpY3Rpb24gdG8gaGVscCBjdWJlIHNldHRsZVxuICAgIGxldCBib3VuZHMgPSB7IHg6IDEyLCB5OiAxMiwgejogOCB9ICAvLyBNb3ZlbWVudCBib3VuZHNcbiAgICBsZXQgZGVmYXVsdFBvc2l0aW9uID0geyB4OiA4LCB5OiA0LCB6OiAwIH0gIC8vIERlZmF1bHQgc3RhcnRpbmcgcG9zaXRpb24gKGZsb2F0aW5nIGFib3ZlIGZsb29yKVxuICAgIGxldCByaXBwbGVzOiBBcnJheTx7IHg6IG51bWJlciwgejogbnVtYmVyLCB0aW1lOiBudW1iZXIsIHN0cmVuZ3RoOiBudW1iZXIsIHJpbmdzOiBhbnlbXSwgcGFydGljbGVzOiBhbnlbXSB9PiA9IFtdXG4gICAgbGV0IGxhc3RDbGlja1RpbWUgPSAwXG4gICAgbGV0IGxhc3RSaXBwbGVUaW1lID0gMFxuICAgIGxldCBnc2FwUmVmOiBhbnkgPSBudWxsXG4gICAgbGV0IGZsb29yTWF0ZXJpYWw6IGFueSA9IG51bGxcbiAgICBsZXQgaXNSZXR1cm5pbmdUb1Bvc2l0aW9uID0gZmFsc2UgIC8vIFRyYWNrIGlmIGN1YmUgaXMgcmV0dXJuaW5nIHRvIGRlZmF1bHQgcG9zaXRpb25cbiAgICBsZXQgcmV0dXJuU3RhcnRUaW1lID0gMFxuXG4gICAgLy8gQ2lyY3VpdCBib2FyZCB3YXZlIHBhcmFtZXRlcnNcbiAgICBjb25zdCByaXBwbGVQYXJhbXMgPSB7XG4gICAgICBtYXhSYWRpdXM6IDEwLjAsXG4gICAgICBleHBhbnNpb25TcGVlZDogMi4wLCAgLy8gU2xvd1xuICAgICAgd2F2ZUhlaWdodDogMC4wOCwgICAgIC8vIEJhcmVseSBub3RpY2VhYmxlIHZlcnRpY2FsIGRpc3BsYWNlbWVudFxuICAgICAgcmluZ1dpZHRoOiAwLjM1LFxuICAgICAgZW1pc3NpdmVHYWluOiAwLjMsICAgIC8vIEJyaWdodGVyIGZvciBjaXJjdWl0IHRyYWNlc1xuICAgICAgaGlnaGxpZ2h0R2FpbjogMC40LFxuICAgICAgZ3JpZFNjYWxlOiAwLjUsICAgICAgIC8vIEdyaWQgbGluZSBzcGFjaW5nIChzbWFsbGVyID0gZGVuc2VyIGdyaWQpXG4gICAgICB0cmFjZUJvb3N0OiAwLjUsICAgICAgLy8gQ2lyY3VpdCB0cmFjZSBicmlnaHRuZXNzXG4gICAgICBhZnRlcmdsb3dEZWNheTogMC45NCxcbiAgICAgIG5vaXNlU2NhbGU6IDMuMCxcbiAgICAgIG5vaXNlU2Nyb2xsU3BlZWQ6IDEuMlxuICAgIH1cblxuXG5cbiAgICBjb25zdCBpbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHNjZW5lXG4gICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpXG5cbiAgICAgIC8vIENyZWF0ZSBjYW1lcmEgKHBvc2l0aW9uZWQgdG8gc2hvdyBjdWJlIG5lYXIgdGl0bGUgb24gcmlnaHQgc2lkZSlcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50XG4gICAgICBjb25zdCBjdyA9IGNvbnRhaW5lcj8uY2xpZW50V2lkdGggfHwgMFxuICAgICAgY29uc3QgY2ggPSBjb250YWluZXI/LmNsaWVudEhlaWdodCB8fCAwXG4gICAgICBjb25zdCB3aWR0aCA9IGN3ID4gMTAgPyBjdyA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5pbm5lcldpZHRoIDogNjAwKVxuICAgICAgY29uc3QgaGVpZ2h0ID0gY2ggPiAxMCA/IGNoIDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmlubmVySGVpZ2h0IDogNjAwKVxuICAgICAgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDY1LCB3aWR0aCAvIGhlaWdodCwgMC4xLCAxMDAwKVxuICAgICAgY2FtZXJhLnBvc2l0aW9uLnNldCg4LCAyLCAyMClcbiAgICAgIGNhbWVyYS5sb29rQXQoOCwgMCwgMClcblxuICAgICAgLy8gU2V0dXAgcmF5Y2FzdGVyIGZvciBtb3VzZSBpbnRlcmFjdGlvblxuICAgICAgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpXG4gICAgICBtb3VzZVZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKClcblxuICAgICAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gICAgICByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgYW50aWFsaWFzOiB0cnVlLCBhbHBoYTogdHJ1ZSB9KVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8oTWF0aC5taW4od2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMikpXG4gICAgICB9XG4gICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgICByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IHRydWVcbiAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50Py5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuXG4gICAgICAvLyBDcmVhdGUgUnViaWsncyBjdWJlIGdyb3VwXG4gICAgICBjdWJlID0gbmV3IFRIUkVFLkdyb3VwKClcblxuICAgICAgLy8gQ3JlYXRlIDN4M3gzIGdyaWQgb2YgY3ViZWxldHNcbiAgICAgIGNvbnN0IG9mZnNldHMgPSBbLTEsIDAsIDFdXG4gICAgICBjb25zdCBnYXAgPSAwLjFcbiAgICAgIGxldCBpbmRleCA9IDBcblxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAzOyB4KyspIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCAzOyB5KyspIHtcbiAgICAgICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IDM7IHorKykge1xuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMC45LCAwLjksIDAuOSlcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGRhcmsgbWF0ZXJpYWxzXG4gICAgICAgICAgICBjb25zdCBpc1RleHR1cmVkID0gaW5kZXggJSA0ID09PSAwXG4gICAgICAgICAgICBjb25zdCBzdXJmYWNlVHlwZSA9IE1hdGgucmFuZG9tKClcblxuICAgICAgICAgICAgbGV0IG1hdGVyaWFsXG4gICAgICAgICAgICBpZiAoc3VyZmFjZVR5cGUgPCAwLjI1ICYmIGlzVGV4dHVyZWQpIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweDJhMmEyYSxcbiAgICAgICAgICAgICAgICBtZXRhbG5lc3M6IDAuNSxcbiAgICAgICAgICAgICAgICByb3VnaG5lc3M6IDAuMyxcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN1cmZhY2VUeXBlIDwgMC41KSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogMHgxYTFhMWEsXG4gICAgICAgICAgICAgICAgbWV0YWxuZXNzOiAwLjUsXG4gICAgICAgICAgICAgICAgcm91Z2huZXNzOiAwLjMsXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdXJmYWNlVHlwZSA8IDAuNzUpIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweDMzMzMzMyxcbiAgICAgICAgICAgICAgICBtZXRhbG5lc3M6IDAuNSxcbiAgICAgICAgICAgICAgICByb3VnaG5lc3M6IDAuMyxcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICAgICAgICAgICAgY29sb3I6IDB4MjUyNTI1LFxuICAgICAgICAgICAgICAgIG1ldGFsbmVzczogMC41LFxuICAgICAgICAgICAgICAgIHJvdWdobmVzczogMC4zLFxuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY3ViZWxldCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbClcbiAgICAgICAgICAgIGN1YmVsZXQucG9zaXRpb24uc2V0KFxuICAgICAgICAgICAgICBvZmZzZXRzW3hdICogKDAuOSArIGdhcCksXG4gICAgICAgICAgICAgIG9mZnNldHNbeV0gKiAoMC45ICsgZ2FwKSxcbiAgICAgICAgICAgICAgb2Zmc2V0c1t6XSAqICgwLjkgKyBnYXApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBjdWJlbGV0LmNhc3RTaGFkb3cgPSB0cnVlXG4gICAgICAgICAgICBjdWJlbGV0LnJlY2VpdmVTaGFkb3cgPSB0cnVlXG5cbiAgICAgICAgICAgIC8vIEFkZCB3aXJlZnJhbWUgZWRnZXNcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VzID0gbmV3IFRIUkVFLkVkZ2VzR2VvbWV0cnkoZ2VvbWV0cnkpXG4gICAgICAgICAgICBjb25zdCBsaW5lID0gbmV3IFRIUkVFLkxpbmVTZWdtZW50cyhcbiAgICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICAgIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweDRiNTU2MywgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuNCB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgY3ViZWxldC5hZGQobGluZSlcblxuICAgICAgICAgICAgY3ViZS5hZGQoY3ViZWxldClcbiAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUG9zaXRpb24gY3ViZSBhdCBkZWZhdWx0IGZsb2F0aW5nIHBvc2l0aW9uIC0gd2lsbCBzdGFydCBmYWxsaW5nIGltbWVkaWF0ZWx5XG4gICAgICBjdWJlLnBvc2l0aW9uLnNldChkZWZhdWx0UG9zaXRpb24ueCwgZGVmYXVsdFBvc2l0aW9uLnksIGRlZmF1bHRQb3NpdGlvbi56KVxuICAgICAgc2NlbmUuYWRkKGN1YmUpXG5cbiAgICAgIC8vIEVuc3VyZSBjdWJlIHJlbmRlcnMgYWZ0ZXIgZ3JpZCB0byBhdm9pZCBcInN1Ym1lcmdpbmdcIiB2aXN1YWxzXG4gICAgICBjdWJlLnRyYXZlcnNlKChvOiBhbnkpID0+IHsgby5yZW5kZXJPcmRlciA9IDEgfSlcblxuICAgICAgLy8gQWRkIGludmlzaWJsZSBib3VuZGluZyBzcGhlcmUgZm9yIGVhc2llciBjbGlja2luZ1xuICAgICAgY29uc3QgaGl0U3BoZXJlR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMi4wLCAxNiwgMTYpXG4gICAgICBjb25zdCBoaXRTcGhlcmVNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSlcbiAgICAgIGNvbnN0IGhpdFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKGhpdFNwaGVyZUdlb21ldHJ5LCBoaXRTcGhlcmVNYXRlcmlhbClcbiAgICAgIGhpdFNwaGVyZS5uYW1lID0gJ2hpdFRhcmdldCdcbiAgICAgIGN1YmUuYWRkKGhpdFNwaGVyZSlcblxuICAgICAgY29uc29sZS5sb2coJ/CfjrIgQ3ViZSBpbml0aWFsaXplZCBhdCBwb3NpdGlvbjonLCBkZWZhdWx0UG9zaXRpb24sICctIGZyZWUtZmFsbGluZyBlbmFibGVkJylcblxuICAgICAgLy8gQ3JlYXRlIGZsb29yIHdpdGggY2lyY3VpdCBib2FyZCBzaGFkZXJcbiAgICAgIGNvbnN0IGZsb29yU2l6ZSA9IDEwMFxuICAgICAgY29uc3QgZmxvb3JTZWdtZW50cyA9IDMwMFxuICAgICAgZmxvb3JHZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KGZsb29yU2l6ZSwgZmxvb3JTaXplLCBmbG9vclNlZ21lbnRzLCBmbG9vclNlZ21lbnRzKVxuICAgICAgZmxvb3JHZW9tZXRyeS5yb3RhdGVYKC1NYXRoLlBJIC8gMilcblxuICAgICAgLy8gQ3VzdG9tIHNoYWRlciBtYXRlcmlhbCBmb3IgY2lyY3VpdCBib2FyZCBlZmZlY3RcbiAgICAgIGZsb29yTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHRpbWU6IHsgdmFsdWU6IDAgfSxcbiAgICAgICAgICBncmlkU2NhbGU6IHsgdmFsdWU6IHJpcHBsZVBhcmFtcy5ncmlkU2NhbGUgfSxcbiAgICAgICAgICBiYXNlQ29sb3I6IHsgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweDBkMTExNykgfSxcbiAgICAgICAgICBncmlkQ29sb3I6IHsgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweDJhM2Y1ZikgfSwgIC8vIERhcmtlciBibHVlIGdyaWQgbGluZXNcbiAgICAgICAgICBnbG93Q29sb3I6IHsgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweDRhOWVmZikgfSwgIC8vIEJyaWdodCBibHVlIGZvciBhY3RpdmF0ZWQgdHJhY2VzXG4gICAgICAgICAgcmlwcGxlUG9zaXRpb25zOiB7IHZhbHVlOiBbbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKV0gfSxcbiAgICAgICAgICByaXBwbGVSYWRpaTogeyB2YWx1ZTogWzAsIDAsIDBdIH0sXG4gICAgICAgICAgcmlwcGxlU3RyZW5ndGhzOiB7IHZhbHVlOiBbMCwgMCwgMF0gfVxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGBcbiAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcblxuICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIHZVdiA9IHV2O1xuICAgICAgICAgICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xuICAgICAgICAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XG4gICAgICAgICAgdW5pZm9ybSBmbG9hdCBncmlkU2NhbGU7XG4gICAgICAgICAgdW5pZm9ybSB2ZWMzIGJhc2VDb2xvcjtcbiAgICAgICAgICB1bmlmb3JtIHZlYzMgZ3JpZENvbG9yO1xuICAgICAgICAgIHVuaWZvcm0gdmVjMyBnbG93Q29sb3I7XG4gICAgICAgICAgdW5pZm9ybSB2ZWMzIHJpcHBsZVBvc2l0aW9uc1szXTtcbiAgICAgICAgICB1bmlmb3JtIGZsb2F0IHJpcHBsZVJhZGlpWzNdO1xuICAgICAgICAgIHVuaWZvcm0gZmxvYXQgcmlwcGxlU3RyZW5ndGhzWzNdO1xuXG4gICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG5cbiAgICAgICAgICAvLyBDaXJjdWl0IGJvYXJkIGdyaWQgcGF0dGVyblxuICAgICAgICAgIGZsb2F0IGdyaWRQYXR0ZXJuKHZlYzIgcG9zKSB7XG4gICAgICAgICAgICB2ZWMyIGdyaWQgPSBhYnMoZnJhY3QocG9zIC8gZ3JpZFNjYWxlIC0gMC41KSAtIDAuNSk7XG4gICAgICAgICAgICBmbG9hdCBsaW5lID0gbWluKGdyaWQueCwgZ3JpZC55KTtcbiAgICAgICAgICAgIHJldHVybiBzbW9vdGhzdGVwKDAuMDIsIDAuMCwgbGluZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2lyY3VpdCB0cmFjZSBwYXR0ZXJuIChtb3JlIGNvbXBsZXgpXG4gICAgICAgICAgZmxvYXQgdHJhY2VQYXR0ZXJuKHZlYzIgcG9zKSB7XG4gICAgICAgICAgICB2ZWMyIHAgPSBwb3MgLyBncmlkU2NhbGU7XG5cbiAgICAgICAgICAgIC8vIEhvcml6b250YWwgYW5kIHZlcnRpY2FsIHRyYWNlc1xuICAgICAgICAgICAgZmxvYXQgaCA9IHN0ZXAoMC44NSwgZnJhY3QocC55KSk7XG4gICAgICAgICAgICBmbG9hdCB2ID0gc3RlcCgwLjg1LCBmcmFjdChwLngpKTtcblxuICAgICAgICAgICAgLy8gRGlhZ29uYWwgdHJhY2VzIChsZXNzIGZyZXF1ZW50KVxuICAgICAgICAgICAgZmxvYXQgZDEgPSBzdGVwKDAuOTIsIGZyYWN0KChwLnggKyBwLnkpICogMC41KSk7XG4gICAgICAgICAgICBmbG9hdCBkMiA9IHN0ZXAoMC45MiwgZnJhY3QoKHAueCAtIHAueSkgKiAwLjUpKTtcblxuICAgICAgICAgICAgcmV0dXJuIG1heChtYXgoaCwgdiksIG1heChkMSwgZDIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICB2ZWMyIHBvcyA9IHZXb3JsZFBvc2l0aW9uLnh6O1xuXG4gICAgICAgICAgICAvLyBCYXNlIGNpcmN1aXQgYm9hcmQgcGF0dGVyblxuICAgICAgICAgICAgZmxvYXQgZ3JpZCA9IGdyaWRQYXR0ZXJuKHBvcyk7XG4gICAgICAgICAgICBmbG9hdCB0cmFjZXMgPSB0cmFjZVBhdHRlcm4ocG9zKTtcbiAgICAgICAgICAgIGZsb2F0IHBhdHRlcm4gPSBtYXgoZ3JpZCAqIDAuNCwgdHJhY2VzKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHJpcHBsZSBhY3RpdmF0aW9uXG4gICAgICAgICAgICBmbG9hdCBhY3RpdmF0aW9uID0gMC4wO1xuICAgICAgICAgICAgZm9yKGludCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICBpZihyaXBwbGVTdHJlbmd0aHNbaV0gPiAwLjApIHtcbiAgICAgICAgICAgICAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UodldvcmxkUG9zaXRpb24ueHosIHJpcHBsZVBvc2l0aW9uc1tpXS54eik7XG4gICAgICAgICAgICAgICAgZmxvYXQgcmlwcGxlRWRnZSA9IGFicyhkaXN0IC0gcmlwcGxlUmFkaWlbaV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWN0aXZhdGUgdHJhY2VzIG5lYXIgdGhlIHJpcHBsZSBlZGdlXG4gICAgICAgICAgICAgICAgaWYocmlwcGxlRWRnZSA8IDAuOCkge1xuICAgICAgICAgICAgICAgICAgZmxvYXQgZWRnZUZhY3RvciA9IDEuMCAtIChyaXBwbGVFZGdlIC8gMC44KTtcbiAgICAgICAgICAgICAgICAgIGFjdGl2YXRpb24gPSBtYXgoYWN0aXZhdGlvbiwgZWRnZUZhY3RvciAqIHJpcHBsZVN0cmVuZ3Roc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBhY3RpdmF0ZSB0cmFjZXMgdGhhdCBoYXZlIGJlZW4gcGFzc2VkIGJ5IHRoZSB3YXZlIChhZnRlcmdsb3cpXG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IHJpcHBsZVJhZGlpW2ldKSB7XG4gICAgICAgICAgICAgICAgICBmbG9hdCBhZnRlcmdsb3cgPSAoMS4wIC0gZGlzdCAvIHJpcHBsZVJhZGlpW2ldKSAqIDAuMTUgKiByaXBwbGVTdHJlbmd0aHNbaV07XG4gICAgICAgICAgICAgICAgICBhY3RpdmF0aW9uID0gbWF4KGFjdGl2YXRpb24sIGFmdGVyZ2xvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1peCBjb2xvcnMgYmFzZWQgb24gYWN0aXZhdGlvblxuICAgICAgICAgICAgdmVjMyBiYXNlUGF0dGVybiA9IG1peChiYXNlQ29sb3IsIGdyaWRDb2xvciwgcGF0dGVybik7XG4gICAgICAgICAgICB2ZWMzIGZpbmFsQ29sb3IgPSBtaXgoYmFzZVBhdHRlcm4sIGdsb3dDb2xvciwgYWN0aXZhdGlvbiAqIHBhdHRlcm4pO1xuXG4gICAgICAgICAgICAvLyBNYWtlIGZsb29yIG1vc3RseSB0cmFuc3BhcmVudCBidXQgc2hvdyBjaXJjdWl0IHBhdHRlcm5cbiAgICAgICAgICAgIGZsb2F0IGFscGhhID0gcGF0dGVybiAqIDAuMiArIGFjdGl2YXRpb24gKiBwYXR0ZXJuICogMC43O1xuXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGZpbmFsQ29sb3IsIGFscGhhKTtcbiAgICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXG4gICAgICB9KVxuXG4gICAgICBmbG9vciA9IG5ldyBUSFJFRS5NZXNoKGZsb29yR2VvbWV0cnksIGZsb29yTWF0ZXJpYWwpXG4gICAgICBmbG9vci5wb3NpdGlvbi5zZXQoOCwgLTQsIDApXG4gICAgICBmbG9vci5yZWNlaXZlU2hhZG93ID0gZmFsc2VcbiAgICAgIHNjZW5lLmFkZChmbG9vcilcblxuICAgICAgY29uc29sZS5sb2coJ+KchSBDaXJjdWl0IGJvYXJkIGZsb29yIGNyZWF0ZWQgd2l0aCBzaGFkZXInKVxuXG4gICAgICAvLyBEYXJrZXIsIG1vcmUgYXRtb3NwaGVyaWMgbGlnaHRpbmcgZm9yIGNpcmN1aXQgYm9hcmQgYWVzdGhldGljXG4gICAgICBjb25zdCBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4MmEyZjNhLCAwLjUpXG4gICAgICBzY2VuZS5hZGQoYW1iaWVudExpZ2h0KVxuXG4gICAgICBjb25zdCBkaXJlY3Rpb25hbExpZ2h0MSA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAwLjUpXG4gICAgICBkaXJlY3Rpb25hbExpZ2h0MS5wb3NpdGlvbi5zZXQoMTAsIDEwLCAxMClcbiAgICAgIHNjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0MSlcblxuICAgICAgY29uc3QgZGlyZWN0aW9uYWxMaWdodDIgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweDQwNDA1MCwgMC4yKVxuICAgICAgZGlyZWN0aW9uYWxMaWdodDIucG9zaXRpb24uc2V0KC0xMCwgLTEwLCAtMTApXG4gICAgICBzY2VuZS5hZGQoZGlyZWN0aW9uYWxMaWdodDIpXG5cbiAgICAgIC8vIFN1YnRsZSBibHVlIGFjY2VudCBsaWdodHMgZm9yIGNpcmN1aXQgYm9hcmQgZ2xvd1xuICAgICAgY29uc3QgcG9pbnRMaWdodDEgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCgweDAwNjZhYSwgMS4wLCAxMDApXG4gICAgICBwb2ludExpZ2h0MS5wb3NpdGlvbi5zZXQoOCwgNSwgMTApXG4gICAgICBzY2VuZS5hZGQocG9pbnRMaWdodDEpXG5cbiAgICAgIGNvbnN0IHBvaW50TGlnaHQyID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoMHgwMDQ0ODgsIDAuOCwgMTAwKVxuICAgICAgcG9pbnRMaWdodDIucG9zaXRpb24uc2V0KDgsIC0zLCAxMClcbiAgICAgIHNjZW5lLmFkZChwb2ludExpZ2h0MilcblxuICAgICAgLy8gQWRkIHJpbSBsaWdodHMgZm9yIGRyYW1hdGljIGVmZmVjdFxuICAgICAgY29uc3QgcmltTGlnaHQxID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoMHgwMDMzNjYsIDAuNCwgMTAwKVxuICAgICAgcmltTGlnaHQxLnBvc2l0aW9uLnNldCgwLCAxMCwgLTEwKVxuICAgICAgLy8gR1NBUCBsb2FkZXIgYW5kIGludHJvIGFuaW1hdGlvbnNcbiAgICAgIGNvbnN0IGxvYWRHU0FQID0gKCk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cgYXMgYW55KS5nc2FwKSByZXR1cm4gcmVzb2x2ZSgod2luZG93IGFzIGFueSkuZ3NhcClcbiAgICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcblxuXG4gICAgICAgICAgcy5zcmMgPSAnaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvZ3NhcC8zLjEyLjIvZ3NhcC5taW4uanMnXG4gICAgICAgICAgcy5hc3luYyA9IHRydWVcbiAgICAgICAgICBzLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKHdpbmRvdyBhcyBhbnkpLmdzYXApXG4gICAgICAgICAgcy5vbmVycm9yID0gcmVqZWN0XG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBnc2FwUmVmID0gYXdhaXQgbG9hZEdTQVAoKVxuICAgICAgICAvLyBTbW9vdGggY2FtZXJhIGludHJvXG4gICAgICAgIGdzYXBSZWYuZnJvbVRvKGNhbWVyYS5wb3NpdGlvbiwgeyB6OiBjYW1lcmEucG9zaXRpb24ueiArIDQsIHk6IGNhbWVyYS5wb3NpdGlvbi55IC0gMC44IH0sIHtcbiAgICAgICAgICB6OiBjYW1lcmEucG9zaXRpb24ueiwgeTogY2FtZXJhLnBvc2l0aW9uLnksIGR1cmF0aW9uOiAxLjIsIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBHU0FQIGZhaWxlZCB0byBsb2FkOyBwcm9jZWVkIHdpdGhvdXQgYW5pbWF0ZWQgaW50cm9cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHVsc2VGbG9vckdsb3cgPSAoc3RyZW5ndGg6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoIWdzYXBSZWYgfHwgIWZsb29yTWF0ZXJpYWwpIHJldHVyblxuICAgICAgICBjb25zdCB0YXJnZXRJbnRlbnNpdHkgPSBNYXRoLm1pbigwLjgsIDAuMyArIHN0cmVuZ3RoICogMS4yKVxuICAgICAgICAvLyBQdWxzZSB0aGUgZW1pc3NpdmUgaW50ZW5zaXR5IHRvIHJldmVhbCBjaXJjdWl0IHBhdHRlcm5cbiAgICAgICAgZ3NhcFJlZi50byhmbG9vck1hdGVyaWFsLCB7XG4gICAgICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IHRhcmdldEludGVuc2l0eSxcbiAgICAgICAgICBkdXJhdGlvbjogMC4xNSxcbiAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCcsXG4gICAgICAgICAgeW95bzogdHJ1ZSxcbiAgICAgICAgICByZXBlYXQ6IDFcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgc2NlbmUuYWRkKHJpbUxpZ2h0MSlcblxuICAgICAgY29uc3QgcmltTGlnaHQyID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoMHgwMDQ0ODgsIDAuMywgMTAwKVxuICAgICAgcmltTGlnaHQyLnBvc2l0aW9uLnNldCgxMCwgLTUsIDApXG4gICAgICBzY2VuZS5hZGQocmltTGlnaHQyKVxuXG4gICAgICAvLyBDcmVhdGUgcGFydGljbGUgc3lzdGVtIGZvciBpbXBhY3QgZWZmZWN0c1xuICAgICAgY29uc3QgcGFydGljbGVDb3VudCA9IDUwMFxuICAgICAgY29uc3QgcGFydGljbGVHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpXG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHBhcnRpY2xlQ291bnQgKiAzKVxuICAgICAgY29uc3QgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShwYXJ0aWNsZUNvdW50ICogMylcbiAgICAgIGNvbnN0IHNpemVzID0gbmV3IEZsb2F0MzJBcnJheShwYXJ0aWNsZUNvdW50KVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2xlQ291bnQ7IGkrKykge1xuICAgICAgICBwb3NpdGlvbnNbaSAqIDNdID0gMFxuICAgICAgICBwb3NpdGlvbnNbaSAqIDMgKyAxXSA9IDBcbiAgICAgICAgcG9zaXRpb25zW2kgKiAzICsgMl0gPSAwXG5cbiAgICAgICAgY29sb3JzW2kgKiAzXSA9IDAuMlxuICAgICAgICBjb2xvcnNbaSAqIDMgKyAxXSA9IDAuNVxuICAgICAgICBjb2xvcnNbaSAqIDMgKyAyXSA9IDEuMFxuXG4gICAgICAgIHNpemVzW2ldID0gTWF0aC5yYW5kb20oKSAqIDAuMSArIDAuMDVcbiAgICAgIH1cblxuICAgICAgcGFydGljbGVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKVxuICAgICAgcGFydGljbGVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKVxuICAgICAgcGFydGljbGVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3NpemUnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHNpemVzLCAxKSlcblxuICAgICAgY29uc3QgcGFydGljbGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7XG4gICAgICAgIHNpemU6IDAuMSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIG9wYWNpdHk6IDAuNixcbiAgICAgICAgdmVydGV4Q29sb3JzOiB0cnVlLFxuICAgICAgICBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyxcbiAgICAgICAgc2l6ZUF0dGVudWF0aW9uOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICBwYXJ0aWNsZVN5c3RlbSA9IG5ldyBUSFJFRS5Qb2ludHMocGFydGljbGVHZW9tZXRyeSwgcGFydGljbGVNYXRlcmlhbClcbiAgICAgIHNjZW5lLmFkZChwYXJ0aWNsZVN5c3RlbSlcblxuXG5cbiAgICAgIGNvbnN0IGNyZWF0ZVJpcHBsZSA9ICh4OiBudW1iZXIsIHo6IG51bWJlciwgc3RyZW5ndGg6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBub3cgPSAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyA/IHBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKSlcbiAgICAgICAgaWYgKG5vdyAtIGxhc3RSaXBwbGVUaW1lIDwgMTIwKSB7XG4gICAgICAgICAgcmV0dXJuIC8vIHRocm90dGxlIHRvIHByZXZlbnQgaGF5d2lyZSBvbiByYXBpZCBib3VuY2VzXG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJpcHBsZVRpbWUgPSBub3dcblxuICAgICAgICAvLyBDcmVhdGUgdWx0cmEtc3VidGxlIHJlYWxpc3RpYyB3YXZlIHJpcHBsZVxuICAgICAgICBjb25zdCBzID0gTWF0aC5taW4oMS4wLCAwLjQgKyBzdHJlbmd0aCAqIDAuNilcblxuICAgICAgICAvLyBDb252ZXJ0IGZsb29yLWxvY2FsIGNvb3JkaW5hdGVzIHRvIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAgICAgIGNvbnN0IHdvcmxkWCA9IHggKyBmbG9vci5wb3NpdGlvbi54XG4gICAgICAgIGNvbnN0IHdvcmxkWiA9IHpcbiAgICAgICAgY29uc3Qgd29ybGRZID0gZmxvb3IucG9zaXRpb24ueVxuXG4gICAgICAgIC8vIENyZWF0ZSByZWFsaXN0aWMgd2F2ZSByaXBwbGUgLSB2ZXJ5IHRoaW4sIGJhcmVseSB2aXNpYmxlXG4gICAgICAgIGNvbnN0IHJpbmdzOiBhbnlbXSA9IFtdXG4gICAgICAgIGNvbnN0IHBhcnRpY2xlczogYW55W10gPSBbXVxuXG4gICAgICAgIC8vIERhcmtlciwgbW9yZSB2aXNpYmxlIHdhdmUgY3Jlc3RcbiAgICAgICAgY29uc3Qgd2F2ZUdlbyA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KDAuNSwgMC4wMzUsIDgsIDY0KSAgLy8gU2xpZ2h0bHkgdGhpY2tlclxuICAgICAgICBjb25zdCB3YXZlTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICBjb2xvcjogMHgzYTZlYTUsICAvLyBEYXJrZXIgYmx1ZSAobW9yZSB2aXNpYmxlKVxuICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgIG9wYWNpdHk6IDAuMjUsICAgIC8vIE1vcmUgdmlzaWJsZVxuICAgICAgICAgIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGUsXG4gICAgICAgICAgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmdcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3Qgd2F2ZSA9IG5ldyBUSFJFRS5NZXNoKHdhdmVHZW8sIHdhdmVNYXQpXG4gICAgICAgIHdhdmUucm90YXRpb24ueCA9IE1hdGguUEkgLyAyXG4gICAgICAgIHdhdmUucG9zaXRpb24uc2V0KHdvcmxkWCwgd29ybGRZLCB3b3JsZFopXG4gICAgICAgIHNjZW5lLmFkZCh3YXZlKVxuICAgICAgICByaW5ncy5wdXNoKHsgbWVzaDogd2F2ZSwgdHlwZTogJ21haW4nLCBpbml0aWFsWTogd29ybGRZIH0pXG5cbiAgICAgICAgcmlwcGxlcy5wdXNoKHsgeCwgeiwgdGltZTogMCwgc3RyZW5ndGg6IHMsIHJpbmdzLCBwYXJ0aWNsZXMgfSlcblxuICAgICAgICAvLyBMaW1pdCB0byAzIGNvbmN1cnJlbnQgd2F2ZXNcbiAgICAgICAgaWYgKHJpcHBsZXMubGVuZ3RoID4gMykge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSByaXBwbGVzLnNoaWZ0KClcbiAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgcmVtb3ZlZC5yaW5ncy5mb3JFYWNoKChyOiBhbnkpID0+IHNjZW5lLnJlbW92ZShyLm1lc2gpKVxuICAgICAgICAgICAgcmVtb3ZlZC5wYXJ0aWNsZXMuZm9yRWFjaCgocDogYW55KSA9PiBzY2VuZS5yZW1vdmUocC5zeXN0ZW0pKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4yKIFVsdHJhLXN1YnRsZSB3YXZlIHJpcHBsZSBjcmVhdGVkIGF0OicsIHdvcmxkWCwgd29ybGRZLCB3b3JsZFopXG4gICAgICB9XG5cbiAgICAgIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBjaXJjdWl0IGJvYXJkIHdhdmUgZWZmZWN0XG4gICAgICBjb25zdCB1cGRhdGVGbG9vclJpcHBsZXMgPSAoKSA9PiB7XG4gICAgICAgIC8vIFVwZGF0ZSBzaGFkZXIgdW5pZm9ybXMgd2l0aCByaXBwbGUgZGF0YVxuICAgICAgICBjb25zdCBwb3NpdGlvbnM6IGFueVtdID0gW11cbiAgICAgICAgY29uc3QgcmFkaWk6IG51bWJlcltdID0gW11cbiAgICAgICAgY29uc3Qgc3RyZW5ndGhzOiBudW1iZXJbXSA9IFtdXG5cbiAgICAgICAgcmlwcGxlcyA9IHJpcHBsZXMuZmlsdGVyKChyaXBwbGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmlwcGxlLnRpbWUgKz0gMC4wMTYgIC8vIH42MGZwc1xuXG4gICAgICAgICAgLy8gU2xvdyBleHBhbnNpb25cbiAgICAgICAgICBjb25zdCBleHBhbnNpb25TcGVlZCA9IHJpcHBsZVBhcmFtcy5leHBhbnNpb25TcGVlZCAgLy8gMi4wIHVuaXRzL3NlY1xuICAgICAgICAgIGNvbnN0IG1heFJhZGl1cyA9IHJpcHBsZVBhcmFtcy5tYXhSYWRpdXMgIC8vIDEwLjAgdW5pdHNcbiAgICAgICAgICBjb25zdCB3YXZlSGVpZ2h0ID0gcmlwcGxlUGFyYW1zLndhdmVIZWlnaHQgIC8vIDAuMDggdW5pdHMgdmVydGljYWxcbiAgICAgICAgICBjb25zdCBjdXJyZW50UmFkaXVzID0gcmlwcGxlLnRpbWUgKiBleHBhbnNpb25TcGVlZFxuXG4gICAgICAgICAgLy8gNSBzZWNvbmQgdG90YWwgZHVyYXRpb24gLSB2ZXJ5IHNsb3dcbiAgICAgICAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gNS4wXG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSByaXBwbGUudGltZSAvIHRvdGFsRHVyYXRpb25cblxuICAgICAgICAgIC8vIFZlcnkgc21vb3RoIGVhc2Utb3V0IGZvciBnZW50bGUgZXhwYW5zaW9uXG4gICAgICAgICAgY29uc3QgZWFzZU91dCA9IDEgLSBNYXRoLnBvdygxIC0gTWF0aC5taW4ocHJvZ3Jlc3MsIDEpLCAyKVxuXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHN0cmVuZ3RoIGZvciBzaGFkZXJcbiAgICAgICAgICBsZXQgc3RyZW5ndGggPSAwXG4gICAgICAgICAgaWYgKHByb2dyZXNzIDwgMC4zKSB7XG4gICAgICAgICAgICBzdHJlbmd0aCA9IChwcm9ncmVzcyAvIDAuMykgKiAwLjhcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyZXNzIDwgMC42KSB7XG4gICAgICAgICAgICBzdHJlbmd0aCA9IDAuOFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlbmd0aCA9IDAuOCAqICgxIC0gKHByb2dyZXNzIC0gMC42KSAvIDAuNClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdG9yZSByaXBwbGUgZGF0YSBmb3Igc2hhZGVyICh1cCB0byAzIHJpcHBsZXMpXG4gICAgICAgICAgaWYgKGluZGV4IDwgMykge1xuICAgICAgICAgICAgY29uc3Qgd29ybGRYID0gcmlwcGxlLnggKyBmbG9vci5wb3NpdGlvbi54XG4gICAgICAgICAgICBjb25zdCB3b3JsZFogPSByaXBwbGUuelxuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMod29ybGRYLCBmbG9vci5wb3NpdGlvbi55LCB3b3JsZFopKVxuICAgICAgICAgICAgcmFkaWkucHVzaChjdXJyZW50UmFkaXVzICogZWFzZU91dClcbiAgICAgICAgICAgIHN0cmVuZ3Rocy5wdXNoKHN0cmVuZ3RoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFuaW1hdGUgdGhlIHdhdmUgcmluZ1xuICAgICAgICAgIHJpcHBsZS5yaW5ncy5mb3JFYWNoKChyaW5nT2JqOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJpbmcgPSByaW5nT2JqLm1lc2hcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxZID0gcmluZ09iai5pbml0aWFsWVxuXG4gICAgICAgICAgICAvLyBTY2FsZSBvdXR3YXJkIHNsb3dseVxuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSAxICsgY3VycmVudFJhZGl1cyAqIGVhc2VPdXQgKiAxLjBcbiAgICAgICAgICAgIHJpbmcuc2NhbGUuc2V0KHNjYWxlLCBzY2FsZSwgc2NhbGUpXG5cbiAgICAgICAgICAgIC8vIFN1YnRsZSB2ZXJ0aWNhbCB3YXZlIG1vdGlvblxuICAgICAgICAgICAgbGV0IGhlaWdodE9mZnNldCA9IDBcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDAuMzUpIHtcbiAgICAgICAgICAgICAgaGVpZ2h0T2Zmc2V0ID0gKHByb2dyZXNzIC8gMC4zNSkgKiB3YXZlSGVpZ2h0XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyZXNzIDwgMC41NSkge1xuICAgICAgICAgICAgICBoZWlnaHRPZmZzZXQgPSB3YXZlSGVpZ2h0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWlnaHRPZmZzZXQgPSB3YXZlSGVpZ2h0ICogKDEgLSAocHJvZ3Jlc3MgLSAwLjU1KSAvIDAuNDUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJpbmcucG9zaXRpb24ueSA9IGluaXRpYWxZICsgaGVpZ2h0T2Zmc2V0XG5cbiAgICAgICAgICAgIC8vIE9wYWNpdHkgYW5pbWF0aW9uXG4gICAgICAgICAgICBsZXQgb3BhY2l0eSA9IDBcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDAuMykge1xuICAgICAgICAgICAgICBvcGFjaXR5ID0gKHByb2dyZXNzIC8gMC4zKSAqIDAuMjVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvZ3Jlc3MgPCAwLjYpIHtcbiAgICAgICAgICAgICAgb3BhY2l0eSA9IDAuMjVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wYWNpdHkgPSAwLjI1ICogKDEgLSAocHJvZ3Jlc3MgLSAwLjYpIC8gMC40KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByaW5nLm1hdGVyaWFsLm9wYWNpdHkgPSBNYXRoLm1heCgwLCBvcGFjaXR5KVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICAvLyBSZW1vdmUgd2hlbiBjb21wbGV0ZVxuICAgICAgICAgIGlmIChyaXBwbGUudGltZSA+PSB0b3RhbER1cmF0aW9uIHx8IGN1cnJlbnRSYWRpdXMgPiBtYXhSYWRpdXMpIHtcbiAgICAgICAgICAgIHJpcHBsZS5yaW5ncy5mb3JFYWNoKChyOiBhbnkpID0+IHNjZW5lLnJlbW92ZShyLm1lc2gpKVxuICAgICAgICAgICAgcmlwcGxlLnBhcnRpY2xlcy5mb3JFYWNoKChwOiBhbnkpID0+IHNjZW5lLnJlbW92ZShwLnN5c3RlbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBVcGRhdGUgZmxvb3Igc2hhZGVyIHVuaWZvcm1zXG4gICAgICAgIGlmIChmbG9vciAmJiBmbG9vci5tYXRlcmlhbCAmJiBmbG9vci5tYXRlcmlhbC51bmlmb3Jtcykge1xuICAgICAgICAgIC8vIFBhZCBhcnJheXMgdG8gbGVuZ3RoIDNcbiAgICAgICAgICB3aGlsZSAocG9zaXRpb25zLmxlbmd0aCA8IDMpIHBvc2l0aW9ucy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApKVxuICAgICAgICAgIHdoaWxlIChyYWRpaS5sZW5ndGggPCAzKSByYWRpaS5wdXNoKDApXG4gICAgICAgICAgd2hpbGUgKHN0cmVuZ3Rocy5sZW5ndGggPCAzKSBzdHJlbmd0aHMucHVzaCgwKVxuXG4gICAgICAgICAgZmxvb3IubWF0ZXJpYWwudW5pZm9ybXMucmlwcGxlUG9zaXRpb25zLnZhbHVlID0gcG9zaXRpb25zXG4gICAgICAgICAgZmxvb3IubWF0ZXJpYWwudW5pZm9ybXMucmlwcGxlUmFkaWkudmFsdWUgPSByYWRpaVxuICAgICAgICAgIGZsb29yLm1hdGVyaWFsLnVuaWZvcm1zLnJpcHBsZVN0cmVuZ3Rocy52YWx1ZSA9IHN0cmVuZ3Roc1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgLy8gTW91c2UgaW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAgICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSByZW5kZXJlci5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIG1vdXNlLnggPSAoKGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQpIC8gcmVjdC53aWR0aCkgKiAyIC0gMVxuICAgICAgICBtb3VzZS55ID0gLSgoZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAvIHJlY3QuaGVpZ2h0KSAqIDIgKyAxXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaG92ZXJpbmcgb3ZlciBjdWJlXG4gICAgICAgIG1vdXNlVmVjdG9yLnggPSBtb3VzZS54XG4gICAgICAgIG1vdXNlVmVjdG9yLnkgPSBtb3VzZS55XG4gICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlVmVjdG9yLCBjYW1lcmEpXG4gICAgICAgIGNvbnN0IGludGVyc2VjdHMgPSByYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KGN1YmUsIHRydWUpXG5cbiAgICAgICAgLy8gQ2hhbmdlIGN1cnNvciB3aGVuIGhvdmVyaW5nXG4gICAgICAgIGlmIChpbnRlcnNlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZW5kZXJlci5kb21FbGVtZW50LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlcmVyLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2dyYWInXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25Nb3VzZUNsaWNrID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxuXG4gICAgICAgIC8vIFJlZHVjZWQgZGVib3VuY2UgdGltZSBmb3IgYmV0dGVyIHJlc3BvbnNpdmVuZXNzXG4gICAgICAgIGlmIChjdXJyZW50VGltZSAtIGxhc3RDbGlja1RpbWUgPCAyMDApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2xpY2tUaW1lID0gY3VycmVudFRpbWVcblxuICAgICAgICAvLyBDYWxjdWxhdGUgbW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gY2FudmFzXG4gICAgICAgIGNvbnN0IHJlY3QgPSByZW5kZXJlci5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIG1vdXNlVmVjdG9yLnggPSAoKGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQpIC8gcmVjdC53aWR0aCkgKiAyIC0gMVxuICAgICAgICBtb3VzZVZlY3Rvci55ID0gLSgoZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAvIHJlY3QuaGVpZ2h0KSAqIDIgKyAxXG5cbiAgICAgICAgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEobW91c2VWZWN0b3IsIGNhbWVyYSlcblxuICAgICAgICAvLyBDaGVjayBpbnRlcnNlY3Rpb24gd2l0aCBjdWJlIGFuZCBhbGwgaXRzIGNoaWxkcmVuIChpbmNsdWRpbmcgaW52aXNpYmxlIGJvdW5kaW5nIHNwaGVyZSlcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0cyA9IHJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QoY3ViZSwgdHJ1ZSlcblxuICAgICAgICBjb25zb2xlLmxvZygn8J+OryBDbGljayBkZXRlY3RlZCEgSW50ZXJzZWN0czonLCBpbnRlcnNlY3RzLmxlbmd0aCwgJ0N1YmUgcG9zaXRpb246JywgY3ViZS5wb3NpdGlvbilcblxuICAgICAgICAvLyBPTkxZIHRyaWdnZXIgaWYgY2xpY2tpbmcgZGlyZWN0bHkgb24gdGhlIGN1YmVcbiAgICAgICAgaWYgKGludGVyc2VjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgSElUISBDdWJlIGNsaWNrZWQgYXQ6JywgaW50ZXJzZWN0c1swXS5wb2ludClcblxuICAgICAgICAgIC8vIENhbmNlbCBhbnkgb25nb2luZyByZXR1cm4gYW5pbWF0aW9uXG4gICAgICAgICAgaXNSZXR1cm5pbmdUb1Bvc2l0aW9uID0gZmFsc2VcbiAgICAgICAgICByZXR1cm5TdGFydFRpbWUgPSAwXG5cbiAgICAgICAgICAvLyBCb3VuY2UgdGhlIGN1YmUgd2l0aCBhIHF1aWNrIGltcHVsc2VcbiAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgICAgICAgY29uc3QgY2xpY2tQb2ludCA9IGludGVyc2VjdHNbMF0ucG9pbnRcbiAgICAgICAgICBkaXJlY3Rpb24uc3ViVmVjdG9ycyhjdWJlLnBvc2l0aW9uLCBjbGlja1BvaW50KS5ub3JtYWxpemUoKVxuXG4gICAgICAgICAgLy8gQXBwbHkgYm91bmNlIGZvcmNlIChSRVBMQUNFIHZlbG9jaXR5LCBub3QgYWRkKVxuICAgICAgICAgIHZlbG9jaXR5LnggPSBkaXJlY3Rpb24ueCAqIDAuMTVcbiAgICAgICAgICB2ZWxvY2l0eS55ID0gTWF0aC5hYnMoZGlyZWN0aW9uLnkpICogMC4xMiArIDAuMTJcbiAgICAgICAgICB2ZWxvY2l0eS56ID0gZGlyZWN0aW9uLnogKiAwLjE1XG5cbiAgICAgICAgICAvLyBQYXJ0aWNsZSBidXJzdCBvbiBjbGlja1xuICAgICAgICAgIGNyZWF0ZVBhcnRpY2xlQnVyc3QoY3ViZS5wb3NpdGlvbi54LCBjdWJlLnBvc2l0aW9uLnksIGN1YmUucG9zaXRpb24ueiwgMC44KVxuXG4gICAgICAgICAgLy8gU2NoZWR1bGUgcmV0dXJuLXRvLXBvc2l0aW9uIGFmdGVyIDEuNSBzZWNvbmRzXG4gICAgICAgICAgcmV0dXJuU3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyAxNTAwXG5cbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+agCBDdWJlIGJvdW5jZWQhIFZlbG9jaXR5OicsIHZlbG9jaXR5KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinYwgTUlTUyAtIENsaWNrIGRpZCBub3QgaGl0IGN1YmUnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHJlbmRlcmVyLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpXG4gICAgICByZW5kZXJlci5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25Nb3VzZUNsaWNrKVxuXG4gICAgICAvLyBGdW5jdGlvbiB0byBjcmVhdGUgcGFydGljbGUgYnVyc3Qgb24gaW1wYWN0XG4gICAgICBjb25zdCBjcmVhdGVQYXJ0aWNsZUJ1cnN0ID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIsIHN0cmVuZ3RoOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gcGFydGljbGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5IGFzIEZsb2F0MzJBcnJheVxuICAgICAgICBjb25zdCBwYXJ0aWNsZUNvdW50ID0gcG9zaXRpb25zLmxlbmd0aCAvIDNcbiAgICAgICAgY29uc3QgYnVyc3RDb3VudCA9IE1hdGgubWluKDUwLCBNYXRoLmZsb29yKHN0cmVuZ3RoICogMTAwKSlcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1cnN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IChpICUgcGFydGljbGVDb3VudCkgKiAzXG4gICAgICAgICAgcG9zaXRpb25zW2lkeF0gPSB4ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC41XG4gICAgICAgICAgcG9zaXRpb25zW2lkeCArIDFdID0geSArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuNVxuICAgICAgICAgIHBvc2l0aW9uc1tpZHggKyAyXSA9IHogKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjVcbiAgICAgICAgfVxuICAgICAgICBwYXJ0aWNsZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIEFuaW1hdGlvbiBsb29wIHdpdGggZW5oYW5jZWQgcGh5c2ljc1xuICAgICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgICAgYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHRpbWUgdG8gcmV0dXJuIHRvIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxuICAgICAgICBpZiAoIWlzUmV0dXJuaW5nVG9Qb3NpdGlvbiAmJiByZXR1cm5TdGFydFRpbWUgPiAwICYmIGN1cnJlbnRUaW1lID49IHJldHVyblN0YXJ0VGltZSkge1xuICAgICAgICAgIGlzUmV0dXJuaW5nVG9Qb3NpdGlvbiA9IHRydWVcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBTdGFydGluZyByZXR1cm4gdG8gZGVmYXVsdCBwb3NpdGlvbicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdG8gcG9zaXRpb24gbG9naWMgKGFwcGx5IGdlbnRsZSBmb3JjZSB0b3dhcmRzIGRlZmF1bHQgcG9zaXRpb24pXG4gICAgICAgIGlmIChpc1JldHVybmluZ1RvUG9zaXRpb24pIHtcbiAgICAgICAgICBjb25zdCBkeCA9IGRlZmF1bHRQb3NpdGlvbi54IC0gY3ViZS5wb3NpdGlvbi54XG4gICAgICAgICAgY29uc3QgZHkgPSBkZWZhdWx0UG9zaXRpb24ueSAtIGN1YmUucG9zaXRpb24ueVxuICAgICAgICAgIGNvbnN0IGR6ID0gZGVmYXVsdFBvc2l0aW9uLnogLSBjdWJlLnBvc2l0aW9uLnpcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopXG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAwLjIpIHtcbiAgICAgICAgICAgIC8vIENsb3NlIGVub3VnaCAtIHNuYXAgdG8gcG9zaXRpb24gYW5kIHN0b3BcbiAgICAgICAgICAgIGN1YmUucG9zaXRpb24uc2V0KGRlZmF1bHRQb3NpdGlvbi54LCBkZWZhdWx0UG9zaXRpb24ueSwgZGVmYXVsdFBvc2l0aW9uLnopXG4gICAgICAgICAgICB2ZWxvY2l0eS54ID0gMFxuICAgICAgICAgICAgdmVsb2NpdHkueSA9IDBcbiAgICAgICAgICAgIHZlbG9jaXR5LnogPSAwXG4gICAgICAgICAgICBpc1JldHVybmluZ1RvUG9zaXRpb24gPSBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuU3RhcnRUaW1lID0gMFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBDdWJlIHJldHVybmVkIHRvIGRlZmF1bHQgcG9zaXRpb24nKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBcHBseSBnZW50bGUgZm9yY2UgdG93YXJkcyBkZWZhdWx0IHBvc2l0aW9uIChpbnN0ZWFkIG9mIHNldHRpbmcgdmVsb2NpdHkgZGlyZWN0bHkpXG4gICAgICAgICAgICBjb25zdCBwdWxsU3RyZW5ndGggPSAwLjAwMlxuICAgICAgICAgICAgdmVsb2NpdHkueCArPSBkeCAqIHB1bGxTdHJlbmd0aFxuICAgICAgICAgICAgdmVsb2NpdHkueSArPSBkeSAqIHB1bGxTdHJlbmd0aFxuICAgICAgICAgICAgdmVsb2NpdHkueiArPSBkeiAqIHB1bGxTdHJlbmd0aFxuXG4gICAgICAgICAgICAvLyBEYW1wZW4gdmVsb2NpdHkgd2hpbGUgcmV0dXJuaW5nXG4gICAgICAgICAgICB2ZWxvY2l0eS54ICo9IDAuOTVcbiAgICAgICAgICAgIHZlbG9jaXR5LnkgKj0gMC45NVxuICAgICAgICAgICAgdmVsb2NpdHkueiAqPSAwLjk1XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFwcGx5IGdyYXZpdHkgd2hlbiBub3QgcmV0dXJuaW5nIHRvIHBvc2l0aW9uXG4gICAgICAgICAgdmVsb2NpdHkueSArPSBncmF2aXR5XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb24gKGtlZXAgY3ViZSBjZW50ZXJlZCBhcm91bmQgeD04KVxuICAgICAgICBjb25zdCBuZXdYID0gY3ViZS5wb3NpdGlvbi54ICsgdmVsb2NpdHkueFxuICAgICAgICBjb25zdCBuZXdZID0gY3ViZS5wb3NpdGlvbi55ICsgdmVsb2NpdHkueVxuICAgICAgICBjb25zdCBuZXdaID0gY3ViZS5wb3NpdGlvbi56ICsgdmVsb2NpdHkuelxuXG4gICAgICAgIGN1YmUucG9zaXRpb24ueCA9IG5ld1hcbiAgICAgICAgY3ViZS5wb3NpdGlvbi55ID0gbmV3WVxuICAgICAgICBjdWJlLnBvc2l0aW9uLnogPSBuZXdaXG5cbiAgICAgICAgLy8gRHluYW1pYyByb3RhdGlvbiBiYXNlZCBvbiB2ZWxvY2l0eSAobW9yZSByZWFsaXN0aWMgcGh5c2ljcylcbiAgICAgICAgY29uc3Qgc3BlZWQgPSBNYXRoLnNxcnQodmVsb2NpdHkueCAqKiAyICsgdmVsb2NpdHkueSAqKiAyICsgdmVsb2NpdHkueiAqKiAyKVxuICAgICAgICBjdWJlLnJvdGF0aW9uLnggKz0gMC4wMDYgKyBzcGVlZCAqIDAuNVxuICAgICAgICBjdWJlLnJvdGF0aW9uLnkgKz0gMC4wMDggKyBzcGVlZCAqIDAuNlxuICAgICAgICBjdWJlLnJvdGF0aW9uLnogKz0gMC4wMDUgKyBzcGVlZCAqIDAuNFxuXG4gICAgICAgIC8vIFVwZGF0ZSBwYXJ0aWNsZSBwb3NpdGlvbnMgKGZhZGUgb3V0KVxuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBwYXJ0aWNsZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkgYXMgRmxvYXQzMkFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgcG9zaXRpb25zW2kgKyAxXSAtPSAwLjAyIC8vIFBhcnRpY2xlcyBmYWxsXG4gICAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMV0gPCAtMTUpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uc1tpICsgMV0gPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnRpY2xlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWVcblxuICAgICAgICAvLyBDaGVjayBmbG9vciBjb2xsaXNpb25cbiAgICAgICAgLy8gQ3ViZSBpcyAzIHVuaXRzIHRhbGwsIHNvIHJhZGl1cyBpcyAxLjUuIEZsb29yIGlzIGF0IHk9LTRcbiAgICAgICAgLy8gQ3ViZSBib3R0b20gPSBjdWJlLnBvc2l0aW9uLnkgLSAxLjVcbiAgICAgICAgY29uc3QgaGFsZlNpemUgPSAxLjVcbiAgICAgICAgY29uc3QgeEEgPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKS5hcHBseVF1YXRlcm5pb24oY3ViZS5xdWF0ZXJuaW9uKVxuY29uc3QgeUEgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKS5hcHBseVF1YXRlcm5pb24oY3ViZS5xdWF0ZXJuaW9uKVxuY29uc3QgekEgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKS5hcHBseVF1YXRlcm5pb24oY3ViZS5xdWF0ZXJuaW9uKVxuY29uc3QgdmVydEV4dGVudCA9IGhhbGZTaXplICogKE1hdGguYWJzKHhBLnkpICsgTWF0aC5hYnMoeUEueSkgKyBNYXRoLmFicyh6QS55KSlcbmNvbnN0IGN1YmVCb3R0b20gPSBjdWJlLnBvc2l0aW9uLnkgLSB2ZXJ0RXh0ZW50XG4gICAgICAgIGNvbnN0IGZsb29yWSA9IC00XG5cbiAgICAgICAgaWYgKGN1YmVCb3R0b20gPD0gZmxvb3JZKSB7XG4gICAgICAgICAgY3ViZS5wb3NpdGlvbi55ID0gZmxvb3JZICsgdmVydEV4dGVudCAgLy8gS2VlcCBjdWJlIHNpdHRpbmcgb24gZmxvb3IgKG9yaWVudGF0aW9uLWF3YXJlKVxuICAgICAgICAgIHZlbG9jaXR5LnkgPSAtdmVsb2NpdHkueSAqIGJvdW5jZVxuICAgICAgICAgIHZlbG9jaXR5LnggKj0gZnJpY3Rpb24gIC8vIEFwcGx5IGZyaWN0aW9uXG4gICAgICAgICAgdmVsb2NpdHkueiAqPSBmcmljdGlvblxuXG4gICAgICAgICAgLy8gQ3JlYXRlIHJpcHBsZSBhbmQgcGFydGljbGUgYnVyc3Qgb24gZmxvb3IgaW1wYWN0IChhZGp1c3QgZm9yIGZsb29yIG9mZnNldClcbiAgICAgICAgICBpZiAoTWF0aC5hYnModmVsb2NpdHkueSkgPiAwLjAwMykge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBwcmVjaXNlIGNvbnRhY3QgcG9pbnQgKHdvcmxkLXNwYWNlKSBieSBzYW1wbGluZyB0aGUgbG93ZXN0IGN1YmUgdmVydGV4XG5jb25zdCBocyA9IGhhbGZTaXplXG5sZXQgbWluWSA9IEluZmluaXR5XG5sZXQgc3VtWCA9IDAsIHN1bVogPSAwLCBjb3VudCA9IDBcbmNvbnN0IG94ID0gW2hzLCBocywgaHMsIGhzLCAtaHMsIC1ocywgLWhzLCAtaHNdXG5jb25zdCBveSA9IFtocywgaHMsIC1ocywgLWhzLCBocywgaHMsIC1ocywgLWhzXVxuY29uc3Qgb3ogPSBbaHMsIC1ocywgaHMsIC1ocywgaHMsIC1ocywgaHMsIC1oc11cbmZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gIGNvbnN0IHd4ID0gY3ViZS5wb3NpdGlvbi54ICsgeEEueCAqIG94W2ldICsgeUEueCAqIG95W2ldICsgekEueCAqIG96W2ldXG4gIGNvbnN0IHd5ID0gY3ViZS5wb3NpdGlvbi55ICsgeEEueSAqIG94W2ldICsgeUEueSAqIG95W2ldICsgekEueSAqIG96W2ldXG4gIGNvbnN0IHd6ID0gY3ViZS5wb3NpdGlvbi56ICsgeEEueiAqIG94W2ldICsgeUEueiAqIG95W2ldICsgekEueiAqIG96W2ldXG4gIGlmICh3eSA8IG1pblkgLSAxZS02KSB7IG1pblkgPSB3eTsgc3VtWCA9IHd4OyBzdW1aID0gd3o7IGNvdW50ID0gMSB9XG4gIGVsc2UgaWYgKE1hdGguYWJzKHd5IC0gbWluWSkgPD0gMWUtNikgeyBzdW1YICs9IHd4OyBzdW1aICs9IHd6OyBjb3VudCsrIH1cbn1cbmNvbnN0IGNvbnRhY3RYV29ybGQgPSBzdW1YIC8gY291bnRcbmNvbnN0IGNvbnRhY3RaV29ybGQgPSBzdW1aIC8gY291bnRcbmNyZWF0ZVJpcHBsZShjb250YWN0WFdvcmxkIC0gZmxvb3IucG9zaXRpb24ueCwgY29udGFjdFpXb3JsZCwgTWF0aC5taW4oMS4yLCBNYXRoLmFicyh2ZWxvY2l0eS55KSAqIDEuMikpICAvLyBDZW50ZXJlZCBvbiBhY3R1YWwgY29udGFjdCBwb2ludCAoY29udmVydGVkIHRvIGZsb29yIGxvY2FsKVxuICAgICAgICAgICAgY3JlYXRlUGFydGljbGVCdXJzdChjdWJlLnBvc2l0aW9uLngsIGN1YmUucG9zaXRpb24ueSwgY3ViZS5wb3NpdGlvbi56LCBNYXRoLmFicyh2ZWxvY2l0eS55KSlcbiAgICAgICAgICAgIHB1bHNlRmxvb3JHbG93KE1hdGguYWJzKHZlbG9jaXR5LnkpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldHRsZSB0aGUgY3ViZSBpZiB2ZWxvY2l0eSBpcyB2ZXJ5IGxvd1xuICAgICAgICAgIGNvbnN0IHRvdGFsVmVsb2NpdHkgPSBNYXRoLnNxcnQodmVsb2NpdHkueCAqKiAyICsgdmVsb2NpdHkueSAqKiAyICsgdmVsb2NpdHkueiAqKiAyKVxuICAgICAgICAgIGlmICh0b3RhbFZlbG9jaXR5IDwgMC4wMDUpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5LnggPSAwXG4gICAgICAgICAgICB2ZWxvY2l0eS55ID0gMFxuICAgICAgICAgICAgdmVsb2NpdHkueiA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBjZWlsaW5nIGNvbGxpc2lvbiAoc29saWQgY2VpbGluZylcbiAgICAgICAgY29uc3QgY2VpbGluZ1kgPSBib3VuZHMueVxuICAgICAgICBpZiAoY3ViZS5wb3NpdGlvbi55ICsgdmVydEV4dGVudCA+PSBjZWlsaW5nWSkge1xuICAgICAgICAgIGN1YmUucG9zaXRpb24ueSA9IGNlaWxpbmdZIC0gdmVydEV4dGVudFxuICAgICAgICAgIHZlbG9jaXR5LnkgPSAtdmVsb2NpdHkueSAqIGJvdW5jZVxuXG4gICAgICAgICAgLy8gTm8gcmlwcGxlcyBvbiBjZWlsaW5nIGhpdHM7IG9wdGlvbmFsIHBhcnRpY2xlIGJ1cnN0IG9ubHlcbiAgICAgICAgICBjcmVhdGVQYXJ0aWNsZUJ1cnN0KGN1YmUucG9zaXRpb24ueCwgY3ViZS5wb3NpdGlvbi55LCBjdWJlLnBvc2l0aW9uLnosIE1hdGguYWJzKHZlbG9jaXR5LnkpICogMC41KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgd2FsbCBjb2xsaXNpb25zIChYIGF4aXMpXG4gICAgICAgIGNvbnN0IG1pblggPSA4IC0gYm91bmRzLnggKyBoYWxmU2l6ZVxuICAgICAgICBjb25zdCBtYXhYID0gOCArIGJvdW5kcy54IC0gaGFsZlNpemVcbiAgICAgICAgaWYgKGN1YmUucG9zaXRpb24ueCA8PSBtaW5YIHx8IGN1YmUucG9zaXRpb24ueCA+PSBtYXhYKSB7XG4gICAgICAgICAgY3ViZS5wb3NpdGlvbi54ID0gY3ViZS5wb3NpdGlvbi54IDw9IG1pblggPyBtaW5YIDogbWF4WFxuICAgICAgICAgIHZlbG9jaXR5LnggPSAtdmVsb2NpdHkueCAqIGJvdW5jZVxuXG4gICAgICAgICAgLy8gTm8gcmlwcGxlcyBvbiB3YWxsIGltcGFjdDsgcGFydGljbGUgYnVyc3Qgb25seVxuICAgICAgICAgIGNyZWF0ZVBhcnRpY2xlQnVyc3QoY3ViZS5wb3NpdGlvbi54LCBjdWJlLnBvc2l0aW9uLnksIGN1YmUucG9zaXRpb24ueiwgTWF0aC5hYnModmVsb2NpdHkueCkgKiAwLjcpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayB3YWxsIGNvbGxpc2lvbnMgKFogYXhpcylcbiAgICAgICAgY29uc3QgbWluWiA9IC1ib3VuZHMueiArIGhhbGZTaXplXG4gICAgICAgIGNvbnN0IG1heFogPSBib3VuZHMueiAtIGhhbGZTaXplXG4gICAgICAgIGlmIChjdWJlLnBvc2l0aW9uLnogPD0gbWluWiB8fCBjdWJlLnBvc2l0aW9uLnogPj0gbWF4Wikge1xuICAgICAgICAgIGN1YmUucG9zaXRpb24ueiA9IGN1YmUucG9zaXRpb24ueiA8PSBtaW5aID8gbWluWiA6IG1heFpcbiAgICAgICAgICB2ZWxvY2l0eS56ID0gLXZlbG9jaXR5LnogKiBib3VuY2VcblxuICAgICAgICAgIC8vIE5vIHJpcHBsZXMgb24gd2FsbCBpbXBhY3Q7IHBhcnRpY2xlIGJ1cnN0IG9ubHlcbiAgICAgICAgICBjcmVhdGVQYXJ0aWNsZUJ1cnN0KGN1YmUucG9zaXRpb24ueCwgY3ViZS5wb3NpdGlvbi55LCBjdWJlLnBvc2l0aW9uLnosIE1hdGguYWJzKHZlbG9jaXR5LnopICogMC43KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGZsb29yIHJpcHBsZXMgKHJldmVhbHMgY2lyY3VpdCBib2FyZClcbiAgICAgICAgdXBkYXRlRmxvb3JSaXBwbGVzKClcblxuICAgICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSlcbiAgICAgIH1cblxuICAgICAgYW5pbWF0ZSgpXG5cbiAgICAgIC8vIEhhbmRsZSByZXNpemVcbiAgICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgICAgIGNvbnN0IGN3ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGhcbiAgICAgICAgY29uc3QgY2ggPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjdyA+IDEwID8gY3cgOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IDYwMClcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY2ggPiAxMCA/IGNoIDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmlubmVySGVpZ2h0IDogNjAwKVxuICAgICAgICBjYW1lcmEuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHRcbiAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpXG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpXG4gICAgICAgIHJlbmRlcmVyLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpXG4gICAgICAgIHJlbmRlcmVyLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbk1vdXNlQ2xpY2spXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkKVxuXG4gICAgICAgIGlmIChyZW5kZXJlciAmJiBjb250YWluZXJSZWYuY3VycmVudD8uY29udGFpbnMocmVuZGVyZXIuZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5yZW1vdmVDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyPy5kaXNwb3NlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0KClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoYW5pbWF0aW9uSWQpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICByZWY9e2NvbnRhaW5lclJlZn1cbiAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIlxuICAgICAgc3R5bGU9e3sgbWluSGVpZ2h0OiAnMTAwdmgnLCBjdXJzb3I6ICdwb2ludGVyJyB9fVxuICAgIC8+XG4gIClcbn1cblxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIlRIUkVFIiwiUnViaWtzQ3ViZSIsImNvbnRhaW5lclJlZiIsImN1cnJlbnQiLCJzY2VuZSIsImNhbWVyYSIsInJlbmRlcmVyIiwiY3ViZSIsImFuaW1hdGlvbklkIiwiZmxvb3IiLCJmbG9vckdlb21ldHJ5IiwibW91c2UiLCJ4IiwieSIsInJheWNhc3RlciIsIm1vdXNlVmVjdG9yIiwicGFydGljbGVzIiwicGFydGljbGVTeXN0ZW0iLCJ0cmFpbFBvc2l0aW9ucyIsInZlbG9jaXR5IiwieiIsImdyYXZpdHkiLCJib3VuY2UiLCJmcmljdGlvbiIsImJvdW5kcyIsImRlZmF1bHRQb3NpdGlvbiIsInJpcHBsZXMiLCJsYXN0Q2xpY2tUaW1lIiwibGFzdFJpcHBsZVRpbWUiLCJnc2FwUmVmIiwiZmxvb3JNYXRlcmlhbCIsImlzUmV0dXJuaW5nVG9Qb3NpdGlvbiIsInJldHVyblN0YXJ0VGltZSIsInJpcHBsZVBhcmFtcyIsIm1heFJhZGl1cyIsImV4cGFuc2lvblNwZWVkIiwid2F2ZUhlaWdodCIsInJpbmdXaWR0aCIsImVtaXNzaXZlR2FpbiIsImhpZ2hsaWdodEdhaW4iLCJncmlkU2NhbGUiLCJ0cmFjZUJvb3N0IiwiYWZ0ZXJnbG93RGVjYXkiLCJub2lzZVNjYWxlIiwibm9pc2VTY3JvbGxTcGVlZCIsImluaXQiLCJjb250YWluZXIiLCJjdyIsImNoIiwid2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRzIiwiZ2FwIiwiaW5kZXgiLCJnZW9tZXRyeSIsImlzVGV4dHVyZWQiLCJzdXJmYWNlVHlwZSIsIm1hdGVyaWFsIiwiY3ViZWxldCIsImVkZ2VzIiwibGluZSIsImhpdFNwaGVyZUdlb21ldHJ5IiwiaGl0U3BoZXJlTWF0ZXJpYWwiLCJoaXRTcGhlcmUiLCJmbG9vclNpemUiLCJmbG9vclNlZ21lbnRzIiwiYW1iaWVudExpZ2h0IiwiZGlyZWN0aW9uYWxMaWdodDEiLCJkaXJlY3Rpb25hbExpZ2h0MiIsInBvaW50TGlnaHQxIiwicG9pbnRMaWdodDIiLCJyaW1MaWdodDEiLCJsb2FkR1NBUCIsImUiLCJwdWxzZUZsb29yR2xvdyIsInJpbUxpZ2h0MiIsInBhcnRpY2xlQ291bnQiLCJwYXJ0aWNsZUdlb21ldHJ5IiwicG9zaXRpb25zIiwiY29sb3JzIiwic2l6ZXMiLCJpIiwicGFydGljbGVNYXRlcmlhbCIsImNyZWF0ZVJpcHBsZSIsInVwZGF0ZUZsb29yUmlwcGxlcyIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUNsaWNrIiwiY3JlYXRlUGFydGljbGVCdXJzdCIsImFuaW1hdGUiLCJoYW5kbGVSZXNpemUiLCJTY2VuZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJwb3NpdGlvbiIsInNldCIsImxvb2tBdCIsIlJheWNhc3RlciIsIlZlY3RvcjIiLCJXZWJHTFJlbmRlcmVyIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJzZXRQaXhlbFJhdGlvIiwiTWF0aCIsIm1pbiIsImRldmljZVBpeGVsUmF0aW8iLCJzZXRTaXplIiwic2hhZG93TWFwIiwiZW5hYmxlZCIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsIkdyb3VwIiwiQm94R2VvbWV0cnkiLCJyYW5kb20iLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsImNvbG9yIiwibWV0YWxuZXNzIiwicm91Z2huZXNzIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwiTWVzaCIsImNhc3RTaGFkb3ciLCJyZWNlaXZlU2hhZG93IiwiRWRnZXNHZW9tZXRyeSIsIkxpbmVTZWdtZW50cyIsIkxpbmVCYXNpY01hdGVyaWFsIiwiYWRkIiwidHJhdmVyc2UiLCJvIiwicmVuZGVyT3JkZXIiLCJTcGhlcmVHZW9tZXRyeSIsIk1lc2hCYXNpY01hdGVyaWFsIiwidmlzaWJsZSIsIm5hbWUiLCJjb25zb2xlIiwibG9nIiwiUGxhbmVHZW9tZXRyeSIsInJvdGF0ZVgiLCJQSSIsIlNoYWRlck1hdGVyaWFsIiwidW5pZm9ybXMiLCJ0aW1lIiwidmFsdWUiLCJiYXNlQ29sb3IiLCJDb2xvciIsImdyaWRDb2xvciIsImdsb3dDb2xvciIsInJpcHBsZVBvc2l0aW9ucyIsIlZlY3RvcjMiLCJyaXBwbGVSYWRpaSIsInJpcHBsZVN0cmVuZ3RocyIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwic2lkZSIsIkRvdWJsZVNpZGUiLCJBbWJpZW50TGlnaHQiLCJEaXJlY3Rpb25hbExpZ2h0IiwiUG9pbnRMaWdodCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ3NhcCIsInMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzcmMiLCJhc3luYyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJoZWFkIiwiZnJvbVRvIiwiZHVyYXRpb24iLCJlYXNlIiwic3RyZW5ndGgiLCJ0YXJnZXRJbnRlbnNpdHkiLCJ0byIsImVtaXNzaXZlSW50ZW5zaXR5IiwieW95byIsInJlcGVhdCIsIkJ1ZmZlckdlb21ldHJ5IiwiRmxvYXQzMkFycmF5Iiwic2V0QXR0cmlidXRlIiwiQnVmZmVyQXR0cmlidXRlIiwiUG9pbnRzTWF0ZXJpYWwiLCJzaXplIiwidmVydGV4Q29sb3JzIiwiYmxlbmRpbmciLCJBZGRpdGl2ZUJsZW5kaW5nIiwic2l6ZUF0dGVudWF0aW9uIiwiUG9pbnRzIiwibm93IiwicGVyZm9ybWFuY2UiLCJEYXRlIiwid29ybGRYIiwid29ybGRaIiwid29ybGRZIiwicmluZ3MiLCJ3YXZlR2VvIiwiVG9ydXNHZW9tZXRyeSIsIndhdmVNYXQiLCJ3YXZlIiwicm90YXRpb24iLCJwdXNoIiwibWVzaCIsInR5cGUiLCJpbml0aWFsWSIsImxlbmd0aCIsInJlbW92ZWQiLCJzaGlmdCIsImZvckVhY2giLCJyIiwicmVtb3ZlIiwicCIsInN5c3RlbSIsInJhZGlpIiwic3RyZW5ndGhzIiwiZmlsdGVyIiwicmlwcGxlIiwiY3VycmVudFJhZGl1cyIsInRvdGFsRHVyYXRpb24iLCJwcm9ncmVzcyIsImVhc2VPdXQiLCJwb3ciLCJyaW5nT2JqIiwicmluZyIsInNjYWxlIiwiaGVpZ2h0T2Zmc2V0IiwibWF4IiwiZXZlbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImxlZnQiLCJjbGllbnRZIiwidG9wIiwic2V0RnJvbUNhbWVyYSIsImludGVyc2VjdHMiLCJpbnRlcnNlY3RPYmplY3QiLCJzdHlsZSIsImN1cnNvciIsImN1cnJlbnRUaW1lIiwicG9pbnQiLCJkaXJlY3Rpb24iLCJjbGlja1BvaW50Iiwic3ViVmVjdG9ycyIsIm5vcm1hbGl6ZSIsImFicyIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRyaWJ1dGVzIiwiYXJyYXkiLCJidXJzdENvdW50IiwiaWR4IiwibmVlZHNVcGRhdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkeCIsImR5IiwiZHoiLCJkaXN0YW5jZSIsInNxcnQiLCJwdWxsU3RyZW5ndGgiLCJuZXdYIiwibmV3WSIsIm5ld1oiLCJzcGVlZCIsImhhbGZTaXplIiwieEEiLCJhcHBseVF1YXRlcm5pb24iLCJxdWF0ZXJuaW9uIiwieUEiLCJ6QSIsInZlcnRFeHRlbnQiLCJjdWJlQm90dG9tIiwiZmxvb3JZIiwiaHMiLCJtaW5ZIiwiSW5maW5pdHkiLCJzdW1YIiwic3VtWiIsImNvdW50Iiwib3giLCJveSIsIm96Iiwid3giLCJ3eSIsInd6IiwiY29udGFjdFhXb3JsZCIsImNvbnRhY3RaV29ybGQiLCJ0b3RhbFZlbG9jaXR5IiwiY2VpbGluZ1kiLCJtaW5YIiwibWF4WCIsIm1pbloiLCJtYXhaIiwicmVuZGVyIiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNvbnRhaW5zIiwicmVtb3ZlQ2hpbGQiLCJkaXNwb3NlIiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIiwibWluSGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/layout/RubiksCube.tsx\n"));

/***/ })

});