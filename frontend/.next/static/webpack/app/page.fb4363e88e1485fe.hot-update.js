"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/layout/RubiksCube.tsx":
/*!**********************************************!*\
  !*** ./src/components/layout/RubiksCube.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RubiksCube: function() { return /* binding */ RubiksCube; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_async_to_generator.js\");\n/* harmony import */ var _swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* __next_internal_client_entry_do_not_use__ RubiksCube auto */ \n\n\nvar _s = $RefreshSig$();\n\n\nfunction RubiksCube() {\n    _s();\n    var containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if ( false || !containerRef.current) return;\n        var scene, camera, renderer, cube, animationId;\n        var floor, floorGeometry;\n        var mouse = {\n            x: 0,\n            y: 0\n        };\n        var raycaster, mouseVector;\n        var particles, particleSystem;\n        var trailPositions = [];\n        // Physics variables - free-falling cube\n        var velocity = {\n            x: 0,\n            y: 0,\n            z: 0\n        } // Will start falling immediately\n        ;\n        var gravity = -0.0005 // Gravity for natural fall\n        ;\n        var bounce = 0.7 // Bouncy\n        ;\n        var friction = 0.98 // Friction to help cube settle\n        ;\n        var bounds = {\n            x: 12,\n            y: 12,\n            z: 8\n        } // Movement bounds\n        ;\n        var defaultPosition = {\n            x: 8,\n            y: 4,\n            z: 0\n        } // Default starting position (floating above floor)\n        ;\n        var ripples = [];\n        var lastClickTime = 0;\n        var lastRippleTime = 0;\n        var gsapRef = null;\n        var floorMaterial = null;\n        var isReturningToPosition = false // Track if cube is returning to default position\n        ;\n        var returnStartTime = 0;\n        // Circuit board wave parameters\n        var rippleParams = {\n            maxRadius: 10.0,\n            expansionSpeed: 2.0,\n            waveHeight: 0.08,\n            ringWidth: 0.35,\n            emissiveGain: 0.3,\n            highlightGain: 0.4,\n            gridScale: 0.5,\n            traceBoost: 0.5,\n            afterglowDecay: 0.94,\n            noiseScale: 3.0,\n            noiseScrollSpeed: 1.2\n        };\n        var init = function() {\n            var _ref = (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_2__._)(function() {\n                var _containerRef_current, container, cw, ch, width, height, offsets, gap, index, x, y, z, geometry, isTextured, surfaceType, material, cubelet, edges, line, hitSphereGeometry, hitSphereMaterial, hitSphere, floorSize, floorSegments, ambientLight, directionalLight1, directionalLight2, pointLight1, pointLight2, rimLight1, loadGSAP, e, pulseFloorGlow, rimLight2, particleCount, particleGeometry, positions, colors, sizes, i, particleMaterial, createRipple, updateFloorRipples, onMouseMove, onMouseClick, createParticleBurst, animate, handleResize;\n                return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_3__.__generator)(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            // Create scene\n                            scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();\n                            // Create camera (positioned to show cube near title on right side)\n                            container = containerRef.current;\n                            cw = (container === null || container === void 0 ? void 0 : container.clientWidth) || 0;\n                            ch = (container === null || container === void 0 ? void 0 : container.clientHeight) || 0;\n                            width = cw > 10 ? cw :  true ? window.innerWidth : 0;\n                            height = ch > 10 ? ch :  true ? window.innerHeight : 0;\n                            camera = new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(65, width / height, 0.1, 1000);\n                            camera.position.set(8, 2, 20);\n                            camera.lookAt(8, 0, 0);\n                            // Setup raycaster for mouse interaction\n                            raycaster = new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster();\n                            mouseVector = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2();\n                            // Create renderer\n                            renderer = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer({\n                                antialias: true,\n                                alpha: true\n                            });\n                            if (true) {\n                                renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\n                            }\n                            renderer.setSize(width, height);\n                            renderer.shadowMap.enabled = true;\n                            (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.appendChild(renderer.domElement);\n                            // Create Rubik's cube group\n                            cube = new three__WEBPACK_IMPORTED_MODULE_4__.Group();\n                            // Create 3x3x3 grid of cubelets\n                            offsets = [\n                                -1,\n                                0,\n                                1\n                            ];\n                            gap = 0.1;\n                            index = 0;\n                            for(x = 0; x < 3; x++){\n                                for(y = 0; y < 3; y++){\n                                    for(z = 0; z < 3; z++){\n                                        geometry = new three__WEBPACK_IMPORTED_MODULE_4__.BoxGeometry(0.9, 0.9, 0.9);\n                                        // Create dark materials\n                                        isTextured = index % 4 === 0;\n                                        surfaceType = Math.random();\n                                        material = void 0;\n                                        if (surfaceType < 0.25 && isTextured) {\n                                            material = new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                                                color: 0x2a2a2a,\n                                                metalness: 0.6,\n                                                roughness: 0.2,\n                                                transparent: false,\n                                                opacity: 1.0,\n                                                emissive: 0x111111,\n                                                emissiveIntensity: 0.15\n                                            });\n                                        } else if (surfaceType < 0.5) {\n                                            material = new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                                                color: 0x1a1a1a,\n                                                metalness: 0.6,\n                                                roughness: 0.2,\n                                                transparent: false,\n                                                opacity: 1.0,\n                                                emissive: 0x111111,\n                                                emissiveIntensity: 0.15\n                                            });\n                                        } else if (surfaceType < 0.75) {\n                                            material = new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                                                color: 0x333333,\n                                                metalness: 0.6,\n                                                roughness: 0.2,\n                                                transparent: false,\n                                                opacity: 1.0,\n                                                emissive: 0x111111,\n                                                emissiveIntensity: 0.15\n                                            });\n                                        } else {\n                                            material = new three__WEBPACK_IMPORTED_MODULE_4__.MeshStandardMaterial({\n                                                color: 0x252525,\n                                                metalness: 0.6,\n                                                roughness: 0.2,\n                                                transparent: false,\n                                                opacity: 1.0,\n                                                emissive: 0x111111,\n                                                emissiveIntensity: 0.15\n                                            });\n                                        }\n                                        cubelet = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(geometry, material);\n                                        cubelet.position.set(offsets[x] * (0.9 + gap), offsets[y] * (0.9 + gap), offsets[z] * (0.9 + gap));\n                                        cubelet.castShadow = true;\n                                        cubelet.receiveShadow = true;\n                                        // Add wireframe edges\n                                        edges = new three__WEBPACK_IMPORTED_MODULE_4__.EdgesGeometry(geometry);\n                                        line = new three__WEBPACK_IMPORTED_MODULE_4__.LineSegments(edges, new three__WEBPACK_IMPORTED_MODULE_4__.LineBasicMaterial({\n                                            color: 0x4b5563,\n                                            transparent: true,\n                                            opacity: 0.4\n                                        }));\n                                        cubelet.add(line);\n                                        cube.add(cubelet);\n                                        index++;\n                                    }\n                                }\n                            }\n                            // Position cube at default floating position - will start falling immediately\n                            cube.position.set(defaultPosition.x, defaultPosition.y, defaultPosition.z);\n                            scene.add(cube);\n                            // Ensure cube renders after grid to avoid \"submerging\" visuals\n                            cube.traverse(function(o) {\n                                o.renderOrder = 1;\n                            });\n                            // Add invisible bounding sphere for easier clicking\n                            hitSphereGeometry = new three__WEBPACK_IMPORTED_MODULE_4__.SphereGeometry(2.0, 16, 16);\n                            hitSphereMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.MeshBasicMaterial({\n                                visible: false,\n                                transparent: true,\n                                opacity: 0\n                            });\n                            hitSphere = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(hitSphereGeometry, hitSphereMaterial);\n                            hitSphere.name = \"hitTarget\";\n                            cube.add(hitSphere);\n                            console.log(\"\\uD83C\\uDFB2 Cube initialized at position:\", defaultPosition, \"- free-falling enabled\");\n                            // Create floor with circuit board shader\n                            floorSize = 100;\n                            floorSegments = 300;\n                            floorGeometry = new three__WEBPACK_IMPORTED_MODULE_4__.PlaneGeometry(floorSize, floorSize, floorSegments, floorSegments);\n                            floorGeometry.rotateX(-Math.PI / 2);\n                            // Custom shader material for circuit board effect\n                            floorMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.ShaderMaterial({\n                                uniforms: {\n                                    time: {\n                                        value: 0\n                                    },\n                                    gridScale: {\n                                        value: rippleParams.gridScale\n                                    },\n                                    baseColor: {\n                                        value: new three__WEBPACK_IMPORTED_MODULE_4__.Color(0x0d1117)\n                                    },\n                                    gridColor: {\n                                        value: new three__WEBPACK_IMPORTED_MODULE_4__.Color(0x2a3f5f)\n                                    },\n                                    glowColor: {\n                                        value: new three__WEBPACK_IMPORTED_MODULE_4__.Color(0x4a9eff)\n                                    },\n                                    ripplePositions: {\n                                        value: [\n                                            new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(),\n                                            new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(),\n                                            new three__WEBPACK_IMPORTED_MODULE_4__.Vector3()\n                                        ]\n                                    },\n                                    rippleRadii: {\n                                        value: [\n                                            0,\n                                            0,\n                                            0\n                                        ]\n                                    },\n                                    rippleStrengths: {\n                                        value: [\n                                            0,\n                                            0,\n                                            0\n                                        ]\n                                    }\n                                },\n                                vertexShader: \"\\n          varying vec2 vUv;\\n          varying vec3 vWorldPosition;\\n\\n          void main() {\\n            vUv = uv;\\n            vec4 worldPosition = modelMatrix * vec4(position, 1.0);\\n            vWorldPosition = worldPosition.xyz;\\n            gl_Position = projectionMatrix * viewMatrix * worldPosition;\\n          }\\n        \",\n                                fragmentShader: \"\\n          uniform float time;\\n          uniform float gridScale;\\n          uniform vec3 baseColor;\\n          uniform vec3 gridColor;\\n          uniform vec3 glowColor;\\n          uniform vec3 ripplePositions[3];\\n          uniform float rippleRadii[3];\\n          uniform float rippleStrengths[3];\\n\\n          varying vec2 vUv;\\n          varying vec3 vWorldPosition;\\n\\n          // Circuit board grid pattern\\n          float gridPattern(vec2 pos) {\\n            vec2 grid = abs(fract(pos / gridScale - 0.5) - 0.5);\\n            float line = min(grid.x, grid.y);\\n            return smoothstep(0.02, 0.0, line);\\n          }\\n\\n          // Circuit trace pattern (more complex)\\n          float tracePattern(vec2 pos) {\\n            vec2 p = pos / gridScale;\\n\\n            // Horizontal and vertical traces\\n            float h = step(0.85, fract(p.y));\\n            float v = step(0.85, fract(p.x));\\n\\n            // Diagonal traces (less frequent)\\n            float d1 = step(0.92, fract((p.x + p.y) * 0.5));\\n            float d2 = step(0.92, fract((p.x - p.y) * 0.5));\\n\\n            return max(max(h, v), max(d1, d2));\\n          }\\n\\n          void main() {\\n            vec2 pos = vWorldPosition.xz;\\n\\n            // Base circuit board pattern\\n            float grid = gridPattern(pos);\\n            float traces = tracePattern(pos);\\n            float pattern = max(grid * 0.4, traces);\\n\\n            // Calculate ripple activation\\n            float activation = 0.0;\\n            for(int i = 0; i < 3; i++) {\\n              if(rippleStrengths[i] > 0.0) {\\n                float dist = distance(vWorldPosition.xz, ripplePositions[i].xz);\\n                float rippleEdge = abs(dist - rippleRadii[i]);\\n\\n                // Activate traces near the ripple edge\\n                if(rippleEdge < 0.8) {\\n                  float edgeFactor = 1.0 - (rippleEdge / 0.8);\\n                  activation = max(activation, edgeFactor * rippleStrengths[i]);\\n                }\\n\\n                // Also activate traces that have been passed by the wave (afterglow)\\n                if(dist < rippleRadii[i]) {\\n                  float afterglow = (1.0 - dist / rippleRadii[i]) * 0.15 * rippleStrengths[i];\\n                  activation = max(activation, afterglow);\\n                }\\n              }\\n            }\\n\\n            // Mix colors based on activation\\n            vec3 basePattern = mix(baseColor, gridColor, pattern);\\n            vec3 finalColor = mix(basePattern, glowColor, activation * pattern);\\n\\n            // Make floor mostly transparent but show circuit pattern\\n            float alpha = pattern * 0.2 + activation * pattern * 0.7;\\n\\n            gl_FragColor = vec4(finalColor, alpha);\\n          }\\n        \",\n                                transparent: true,\n                                side: three__WEBPACK_IMPORTED_MODULE_4__.DoubleSide\n                            });\n                            floor = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(floorGeometry, floorMaterial);\n                            floor.position.set(8, -4, 0);\n                            floor.receiveShadow = false;\n                            scene.add(floor);\n                            console.log(\"✅ Circuit board floor created with shader\");\n                            // Darker, more atmospheric lighting for circuit board aesthetic\n                            ambientLight = new three__WEBPACK_IMPORTED_MODULE_4__.AmbientLight(0x2a2f3a, 0.5);\n                            scene.add(ambientLight);\n                            directionalLight1 = new three__WEBPACK_IMPORTED_MODULE_4__.DirectionalLight(0xffffff, 0.5);\n                            directionalLight1.position.set(10, 10, 10);\n                            scene.add(directionalLight1);\n                            directionalLight2 = new three__WEBPACK_IMPORTED_MODULE_4__.DirectionalLight(0x404050, 0.2);\n                            directionalLight2.position.set(-10, -10, -10);\n                            scene.add(directionalLight2);\n                            // Subtle blue accent lights for circuit board glow\n                            pointLight1 = new three__WEBPACK_IMPORTED_MODULE_4__.PointLight(0x0066aa, 1.0, 100);\n                            pointLight1.position.set(8, 5, 10);\n                            scene.add(pointLight1);\n                            pointLight2 = new three__WEBPACK_IMPORTED_MODULE_4__.PointLight(0x004488, 0.8, 100);\n                            pointLight2.position.set(8, -3, 10);\n                            scene.add(pointLight2);\n                            // Add rim lights for dramatic effect\n                            rimLight1 = new three__WEBPACK_IMPORTED_MODULE_4__.PointLight(0x003366, 0.4, 100);\n                            rimLight1.position.set(0, 10, -10);\n                            // GSAP loader and intro animations\n                            loadGSAP = function() {\n                                return new Promise(function(resolve, reject) {\n                                    if ( true && window.gsap) return resolve(window.gsap);\n                                    var s = document.createElement(\"script\");\n                                    s.src = \"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js\";\n                                    s.async = true;\n                                    s.onload = function() {\n                                        return resolve(window.gsap);\n                                    };\n                                    s.onerror = reject;\n                                    document.head.appendChild(s);\n                                });\n                            };\n                            _state.label = 1;\n                        case 1:\n                            _state.trys.push([\n                                1,\n                                3,\n                                ,\n                                4\n                            ]);\n                            return [\n                                4,\n                                loadGSAP()\n                            ];\n                        case 2:\n                            gsapRef = _state.sent();\n                            // Smooth camera intro\n                            gsapRef.fromTo(camera.position, {\n                                z: camera.position.z + 4,\n                                y: camera.position.y - 0.8\n                            }, {\n                                z: camera.position.z,\n                                y: camera.position.y,\n                                duration: 1.2,\n                                ease: \"power2.out\"\n                            });\n                            return [\n                                3,\n                                4\n                            ];\n                        case 3:\n                            e = _state.sent();\n                            return [\n                                3,\n                                4\n                            ];\n                        case 4:\n                            pulseFloorGlow = function(strength) {\n                                if (!gsapRef || !floorMaterial) return;\n                                var targetIntensity = Math.min(0.8, 0.3 + strength * 1.2);\n                                // Pulse the emissive intensity to reveal circuit pattern\n                                gsapRef.to(floorMaterial, {\n                                    emissiveIntensity: targetIntensity,\n                                    duration: 0.15,\n                                    ease: \"power2.out\",\n                                    yoyo: true,\n                                    repeat: 1\n                                });\n                            };\n                            scene.add(rimLight1);\n                            rimLight2 = new three__WEBPACK_IMPORTED_MODULE_4__.PointLight(0x004488, 0.3, 100);\n                            rimLight2.position.set(10, -5, 0);\n                            scene.add(rimLight2);\n                            // Create particle system for impact effects\n                            particleCount = 500;\n                            particleGeometry = new three__WEBPACK_IMPORTED_MODULE_4__.BufferGeometry();\n                            positions = new Float32Array(particleCount * 3);\n                            colors = new Float32Array(particleCount * 3);\n                            sizes = new Float32Array(particleCount);\n                            for(i = 0; i < particleCount; i++){\n                                positions[i * 3] = 0;\n                                positions[i * 3 + 1] = 0;\n                                positions[i * 3 + 2] = 0;\n                                colors[i * 3] = 0.2;\n                                colors[i * 3 + 1] = 0.5;\n                                colors[i * 3 + 2] = 1.0;\n                                sizes[i] = Math.random() * 0.1 + 0.05;\n                            }\n                            particleGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_4__.BufferAttribute(positions, 3));\n                            particleGeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_4__.BufferAttribute(colors, 3));\n                            particleGeometry.setAttribute(\"size\", new three__WEBPACK_IMPORTED_MODULE_4__.BufferAttribute(sizes, 1));\n                            particleMaterial = new three__WEBPACK_IMPORTED_MODULE_4__.PointsMaterial({\n                                size: 0.1,\n                                transparent: true,\n                                opacity: 0.6,\n                                vertexColors: true,\n                                blending: three__WEBPACK_IMPORTED_MODULE_4__.AdditiveBlending,\n                                sizeAttenuation: true\n                            });\n                            particleSystem = new three__WEBPACK_IMPORTED_MODULE_4__.Points(particleGeometry, particleMaterial);\n                            scene.add(particleSystem);\n                            createRipple = function(x, z, strength) {\n                                var now = typeof performance !== \"undefined\" ? performance.now() : Date.now();\n                                if (now - lastRippleTime < 120) {\n                                    return; // throttle to prevent haywire on rapid bounces\n                                }\n                                lastRippleTime = now;\n                                // Create ultra-subtle realistic wave ripple\n                                var s = Math.min(1.0, 0.4 + strength * 0.6);\n                                // Convert floor-local coordinates to world coordinates\n                                var worldX = x + floor.position.x;\n                                var worldZ = z;\n                                var worldY = floor.position.y;\n                                // Create realistic wave ripple - very thin, barely visible\n                                var rings = [];\n                                var particles = [];\n                                // Darker, more visible wave crest\n                                var waveGeo = new three__WEBPACK_IMPORTED_MODULE_4__.TorusGeometry(0.5, 0.035, 8, 64) // Slightly thicker\n                                ;\n                                var waveMat = new three__WEBPACK_IMPORTED_MODULE_4__.MeshBasicMaterial({\n                                    color: 0x3a6ea5,\n                                    transparent: true,\n                                    opacity: 0.25,\n                                    side: three__WEBPACK_IMPORTED_MODULE_4__.DoubleSide,\n                                    blending: three__WEBPACK_IMPORTED_MODULE_4__.AdditiveBlending\n                                });\n                                var wave = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(waveGeo, waveMat);\n                                wave.rotation.x = Math.PI / 2;\n                                wave.position.set(worldX, worldY, worldZ);\n                                scene.add(wave);\n                                rings.push({\n                                    mesh: wave,\n                                    type: \"main\",\n                                    initialY: worldY\n                                });\n                                ripples.push({\n                                    x: x,\n                                    z: z,\n                                    time: 0,\n                                    strength: s,\n                                    rings: rings,\n                                    particles: particles\n                                });\n                                // Limit to 3 concurrent waves\n                                if (ripples.length > 3) {\n                                    var removed = ripples.shift();\n                                    if (removed) {\n                                        removed.rings.forEach(function(r) {\n                                            return scene.remove(r.mesh);\n                                        });\n                                        removed.particles.forEach(function(p) {\n                                            return scene.remove(p.system);\n                                        });\n                                    }\n                                }\n                                console.log(\"\\uD83C\\uDF0A Ultra-subtle wave ripple created at:\", worldX, worldY, worldZ);\n                            };\n                            // Function to update circuit board wave effect\n                            updateFloorRipples = function() {\n                                // Update shader uniforms with ripple data\n                                var positions = [];\n                                var radii = [];\n                                var strengths = [];\n                                ripples = ripples.filter(function(ripple, index) {\n                                    ripple.time += 0.016 // ~60fps\n                                    ;\n                                    // Slow expansion\n                                    var expansionSpeed = rippleParams.expansionSpeed // 2.0 units/sec\n                                    ;\n                                    var maxRadius = rippleParams.maxRadius // 10.0 units\n                                    ;\n                                    var waveHeight = rippleParams.waveHeight // 0.08 units vertical\n                                    ;\n                                    var currentRadius = ripple.time * expansionSpeed;\n                                    // 5 second total duration - very slow\n                                    var totalDuration = 5.0;\n                                    var progress = ripple.time / totalDuration;\n                                    // Very smooth ease-out for gentle expansion\n                                    var easeOut = 1 - Math.pow(1 - Math.min(progress, 1), 2);\n                                    // Calculate strength for shader\n                                    var strength = 0;\n                                    if (progress < 0.3) {\n                                        strength = progress / 0.3 * 0.8;\n                                    } else if (progress < 0.6) {\n                                        strength = 0.8;\n                                    } else {\n                                        strength = 0.8 * (1 - (progress - 0.6) / 0.4);\n                                    }\n                                    // Store ripple data for shader (up to 3 ripples)\n                                    if (index < 3) {\n                                        var worldX = ripple.x + floor.position.x;\n                                        var worldZ = ripple.z;\n                                        positions.push(new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(worldX, floor.position.y, worldZ));\n                                        radii.push(currentRadius * easeOut);\n                                        strengths.push(strength);\n                                    }\n                                    // Animate the wave ring\n                                    ripple.rings.forEach(function(ringObj) {\n                                        var ring = ringObj.mesh;\n                                        var initialY = ringObj.initialY;\n                                        // Scale outward slowly\n                                        var scale = 1 + currentRadius * easeOut * 1.0;\n                                        ring.scale.set(scale, scale, scale);\n                                        // Subtle vertical wave motion\n                                        var heightOffset = 0;\n                                        if (progress < 0.35) {\n                                            heightOffset = progress / 0.35 * waveHeight;\n                                        } else if (progress < 0.55) {\n                                            heightOffset = waveHeight;\n                                        } else {\n                                            heightOffset = waveHeight * (1 - (progress - 0.55) / 0.45);\n                                        }\n                                        ring.position.y = initialY + heightOffset;\n                                        // Opacity animation\n                                        var opacity = 0;\n                                        if (progress < 0.3) {\n                                            opacity = progress / 0.3 * 0.25;\n                                        } else if (progress < 0.6) {\n                                            opacity = 0.25;\n                                        } else {\n                                            opacity = 0.25 * (1 - (progress - 0.6) / 0.4);\n                                        }\n                                        ring.material.opacity = Math.max(0, opacity);\n                                    });\n                                    // Remove when complete\n                                    if (ripple.time >= totalDuration || currentRadius > maxRadius) {\n                                        ripple.rings.forEach(function(r) {\n                                            return scene.remove(r.mesh);\n                                        });\n                                        ripple.particles.forEach(function(p) {\n                                            return scene.remove(p.system);\n                                        });\n                                        return false;\n                                    }\n                                    return true;\n                                });\n                                // Update floor shader uniforms\n                                if (floor && floor.material && floor.material.uniforms) {\n                                    // Pad arrays to length 3\n                                    while(positions.length < 3)positions.push(new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0));\n                                    while(radii.length < 3)radii.push(0);\n                                    while(strengths.length < 3)strengths.push(0);\n                                    floor.material.uniforms.ripplePositions.value = positions;\n                                    floor.material.uniforms.rippleRadii.value = radii;\n                                    floor.material.uniforms.rippleStrengths.value = strengths;\n                                }\n                            };\n                            // Mouse interaction handlers\n                            onMouseMove = function(event) {\n                                var rect = renderer.domElement.getBoundingClientRect();\n                                mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n                                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n                                // Check if hovering over cube\n                                mouseVector.x = mouse.x;\n                                mouseVector.y = mouse.y;\n                                raycaster.setFromCamera(mouseVector, camera);\n                                var intersects = raycaster.intersectObject(cube, true);\n                                // Change cursor when hovering\n                                if (intersects.length > 0) {\n                                    renderer.domElement.style.cursor = \"pointer\";\n                                } else {\n                                    renderer.domElement.style.cursor = \"grab\";\n                                }\n                            };\n                            onMouseClick = function(event) {\n                                var currentTime = Date.now();\n                                // Reduced debounce time for better responsiveness\n                                if (currentTime - lastClickTime < 200) {\n                                    return;\n                                }\n                                lastClickTime = currentTime;\n                                // Calculate mouse position relative to canvas\n                                var rect = renderer.domElement.getBoundingClientRect();\n                                mouseVector.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n                                mouseVector.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n                                raycaster.setFromCamera(mouseVector, camera);\n                                // Check intersection with cube and all its children (including invisible bounding sphere)\n                                var intersects = raycaster.intersectObject(cube, true);\n                                console.log(\"\\uD83C\\uDFAF Click detected! Intersects:\", intersects.length, \"Cube position:\", cube.position);\n                                // ONLY trigger if clicking directly on the cube\n                                if (intersects.length > 0) {\n                                    console.log(\"✅ HIT! Cube clicked at:\", intersects[0].point);\n                                    // Cancel any ongoing return animation\n                                    isReturningToPosition = false;\n                                    returnStartTime = 0;\n                                    // Bounce the cube with a quick impulse\n                                    var direction = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n                                    var clickPoint = intersects[0].point;\n                                    direction.subVectors(cube.position, clickPoint).normalize();\n                                    // Apply bounce force (REPLACE velocity, not add)\n                                    velocity.x = direction.x * 0.15;\n                                    velocity.y = Math.abs(direction.y) * 0.12 + 0.12;\n                                    velocity.z = direction.z * 0.15;\n                                    // Particle burst on click\n                                    createParticleBurst(cube.position.x, cube.position.y, cube.position.z, 0.8);\n                                    // Schedule return-to-position after 1.5 seconds\n                                    returnStartTime = currentTime + 1500;\n                                    console.log(\"\\uD83D\\uDE80 Cube bounced! Velocity:\", velocity);\n                                } else {\n                                    console.log(\"❌ MISS - Click did not hit cube\");\n                                }\n                            };\n                            // Add event listeners\n                            renderer.domElement.addEventListener(\"mousemove\", onMouseMove);\n                            renderer.domElement.addEventListener(\"click\", onMouseClick);\n                            // Function to create particle burst on impact\n                            createParticleBurst = function(x, y, z, strength) {\n                                var positions = particleGeometry.attributes.position.array;\n                                var particleCount = positions.length / 3;\n                                var burstCount = Math.min(50, Math.floor(strength * 100));\n                                for(var i = 0; i < burstCount; i++){\n                                    var idx = i % particleCount * 3;\n                                    positions[idx] = x + (Math.random() - 0.5) * 0.5;\n                                    positions[idx + 1] = y + (Math.random() - 0.5) * 0.5;\n                                    positions[idx + 2] = z + (Math.random() - 0.5) * 0.5;\n                                }\n                                particleGeometry.attributes.position.needsUpdate = true;\n                            };\n                            // Animation loop with enhanced physics\n                            animate = function() {\n                                animationId = requestAnimationFrame(animate);\n                                // Check if it's time to return to position\n                                var currentTime = Date.now();\n                                if (!isReturningToPosition && returnStartTime > 0 && currentTime >= returnStartTime) {\n                                    isReturningToPosition = true;\n                                    console.log(\"\\uD83D\\uDD04 Starting return to default position\");\n                                }\n                                // Return to position logic (apply gentle force towards default position)\n                                if (isReturningToPosition) {\n                                    var dx = defaultPosition.x - cube.position.x;\n                                    var dy = defaultPosition.y - cube.position.y;\n                                    var dz = defaultPosition.z - cube.position.z;\n                                    var distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                                    if (distance < 0.2) {\n                                        // Close enough - snap to position and stop\n                                        cube.position.set(defaultPosition.x, defaultPosition.y, defaultPosition.z);\n                                        velocity.x = 0;\n                                        velocity.y = 0;\n                                        velocity.z = 0;\n                                        isReturningToPosition = false;\n                                        returnStartTime = 0;\n                                        console.log(\"✅ Cube returned to default position\");\n                                    } else {\n                                        // Apply gentle force towards default position (instead of setting velocity directly)\n                                        var pullStrength = 0.002;\n                                        velocity.x += dx * pullStrength;\n                                        velocity.y += dy * pullStrength;\n                                        velocity.z += dz * pullStrength;\n                                        // Dampen velocity while returning\n                                        velocity.x *= 0.95;\n                                        velocity.y *= 0.95;\n                                        velocity.z *= 0.95;\n                                    }\n                                } else {\n                                    // Apply gravity when not returning to position\n                                    velocity.y += gravity;\n                                }\n                                // Update position (keep cube centered around x=8)\n                                var newX = cube.position.x + velocity.x;\n                                var newY = cube.position.y + velocity.y;\n                                var newZ = cube.position.z + velocity.z;\n                                cube.position.x = newX;\n                                cube.position.y = newY;\n                                cube.position.z = newZ;\n                                // Dynamic rotation based on velocity (more realistic physics)\n                                var speed = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2) + Math.pow(velocity.z, 2));\n                                cube.rotation.x += 0.006 + speed * 0.5;\n                                cube.rotation.y += 0.008 + speed * 0.6;\n                                cube.rotation.z += 0.005 + speed * 0.4;\n                                // Update particle positions (fade out)\n                                var positions = particleGeometry.attributes.position.array;\n                                for(var i = 0; i < positions.length; i += 3){\n                                    positions[i + 1] -= 0.02 // Particles fall\n                                    ;\n                                    if (positions[i + 1] < -15) {\n                                        positions[i + 1] = 0;\n                                    }\n                                }\n                                particleGeometry.attributes.position.needsUpdate = true;\n                                // Check floor collision\n                                // Cube is 3 units tall, so radius is 1.5. Floor is at y=-4\n                                // Cube bottom = cube.position.y - 1.5\n                                var halfSize = 1.5;\n                                var xA = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 0, 0).applyQuaternion(cube.quaternion);\n                                var yA = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0).applyQuaternion(cube.quaternion);\n                                var zA = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 1).applyQuaternion(cube.quaternion);\n                                var vertExtent = halfSize * (Math.abs(xA.y) + Math.abs(yA.y) + Math.abs(zA.y));\n                                var cubeBottom = cube.position.y - vertExtent;\n                                var floorY = -4;\n                                if (cubeBottom <= floorY) {\n                                    cube.position.y = floorY + vertExtent // Keep cube sitting on floor (orientation-aware)\n                                    ;\n                                    velocity.y = -velocity.y * bounce;\n                                    velocity.x *= friction // Apply friction\n                                    ;\n                                    velocity.z *= friction;\n                                    // Create ripple and particle burst on floor impact (adjust for floor offset)\n                                    if (Math.abs(velocity.y) > 0.003) {\n                                        // Compute precise contact point (world-space) by sampling the lowest cube vertex\n                                        var hs = halfSize;\n                                        var minY = Infinity;\n                                        var sumX = 0, sumZ = 0, count = 0;\n                                        var ox = [\n                                            hs,\n                                            hs,\n                                            hs,\n                                            hs,\n                                            -hs,\n                                            -hs,\n                                            -hs,\n                                            -hs\n                                        ];\n                                        var oy = [\n                                            hs,\n                                            hs,\n                                            -hs,\n                                            -hs,\n                                            hs,\n                                            hs,\n                                            -hs,\n                                            -hs\n                                        ];\n                                        var oz = [\n                                            hs,\n                                            -hs,\n                                            hs,\n                                            -hs,\n                                            hs,\n                                            -hs,\n                                            hs,\n                                            -hs\n                                        ];\n                                        for(var i1 = 0; i1 < 8; i1++){\n                                            var wx = cube.position.x + xA.x * ox[i1] + yA.x * oy[i1] + zA.x * oz[i1];\n                                            var wy = cube.position.y + xA.y * ox[i1] + yA.y * oy[i1] + zA.y * oz[i1];\n                                            var wz = cube.position.z + xA.z * ox[i1] + yA.z * oy[i1] + zA.z * oz[i1];\n                                            if (wy < minY - 1e-6) {\n                                                minY = wy;\n                                                sumX = wx;\n                                                sumZ = wz;\n                                                count = 1;\n                                            } else if (Math.abs(wy - minY) <= 1e-6) {\n                                                sumX += wx;\n                                                sumZ += wz;\n                                                count++;\n                                            }\n                                        }\n                                        var contactXWorld = sumX / count;\n                                        var contactZWorld = sumZ / count;\n                                        createRipple(contactXWorld - floor.position.x, contactZWorld, Math.min(1.2, Math.abs(velocity.y) * 1.2)) // Centered on actual contact point (converted to floor local)\n                                        ;\n                                        createParticleBurst(cube.position.x, cube.position.y, cube.position.z, Math.abs(velocity.y));\n                                        pulseFloorGlow(Math.abs(velocity.y));\n                                    }\n                                    // Settle the cube if velocity is very low\n                                    var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2) + Math.pow(velocity.z, 2));\n                                    if (totalVelocity < 0.005) {\n                                        velocity.x = 0;\n                                        velocity.y = 0;\n                                        velocity.z = 0;\n                                    }\n                                }\n                                // Check ceiling collision (solid ceiling)\n                                var ceilingY = bounds.y;\n                                if (cube.position.y + vertExtent >= ceilingY) {\n                                    cube.position.y = ceilingY - vertExtent;\n                                    velocity.y = -velocity.y * bounce;\n                                    // No ripples on ceiling hits; optional particle burst only\n                                    createParticleBurst(cube.position.x, cube.position.y, cube.position.z, Math.abs(velocity.y) * 0.5);\n                                }\n                                // Check wall collisions (X axis)\n                                var minX = 8 - bounds.x + halfSize;\n                                var maxX = 8 + bounds.x - halfSize;\n                                if (cube.position.x <= minX || cube.position.x >= maxX) {\n                                    cube.position.x = cube.position.x <= minX ? minX : maxX;\n                                    velocity.x = -velocity.x * bounce;\n                                    // No ripples on wall impact; particle burst only\n                                    createParticleBurst(cube.position.x, cube.position.y, cube.position.z, Math.abs(velocity.x) * 0.7);\n                                }\n                                // Check wall collisions (Z axis)\n                                var minZ = -bounds.z + halfSize;\n                                var maxZ = bounds.z - halfSize;\n                                if (cube.position.z <= minZ || cube.position.z >= maxZ) {\n                                    cube.position.z = cube.position.z <= minZ ? minZ : maxZ;\n                                    velocity.z = -velocity.z * bounce;\n                                    // No ripples on wall impact; particle burst only\n                                    createParticleBurst(cube.position.x, cube.position.y, cube.position.z, Math.abs(velocity.z) * 0.7);\n                                }\n                                // Update floor ripples (reveals circuit board)\n                                updateFloorRipples();\n                                renderer.render(scene, camera);\n                            };\n                            animate();\n                            // Handle resize\n                            handleResize = function() {\n                                if (!containerRef.current) return;\n                                var cw = containerRef.current.clientWidth;\n                                var ch = containerRef.current.clientHeight;\n                                var width = cw > 10 ? cw :  true ? window.innerWidth : 0;\n                                var height = ch > 10 ? ch :  true ? window.innerHeight : 0;\n                                camera.aspect = width / height;\n                                camera.updateProjectionMatrix();\n                                renderer.setSize(width, height);\n                            };\n                            window.addEventListener(\"resize\", handleResize);\n                            return [\n                                2,\n                                function() {\n                                    var _containerRef_current;\n                                    window.removeEventListener(\"resize\", handleResize);\n                                    renderer.domElement.removeEventListener(\"mousemove\", onMouseMove);\n                                    renderer.domElement.removeEventListener(\"click\", onMouseClick);\n                                    cancelAnimationFrame(animationId);\n                                    if (renderer && ((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.contains(renderer.domElement))) {\n                                        containerRef.current.removeChild(renderer.domElement);\n                                    }\n                                    renderer === null || renderer === void 0 ? void 0 : renderer.dispose();\n                                }\n                            ];\n                    }\n                });\n            });\n            return function init() {\n                return _ref.apply(this, arguments);\n            };\n        }();\n        init();\n        return function() {\n            if (animationId) cancelAnimationFrame(animationId);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"w-full h-full\",\n        style: {\n            minHeight: \"100vh\",\n            cursor: \"pointer\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\josel\\\\OneDrive\\\\Desktop\\\\GitHub\\\\apps\\\\frontend\\\\src\\\\components\\\\layout\\\\RubiksCube.tsx\",\n        lineNumber: 830,\n        columnNumber: 5\n    }, this);\n}\n_s(RubiksCube, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = RubiksCube;\nvar _c;\n$RefreshReg$(_c, \"RubiksCube\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xheW91dC9SdWJpa3NDdWJlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUV5QztBQUNYO0FBRXZCLFNBQVNHOztJQUNkLElBQU1DLGVBQWVILDZDQUFNQSxDQUFpQjtJQUU1Q0QsZ0RBQVNBLENBQUM7UUFDUixJQUFJLE1BQWtCLElBQWUsQ0FBQ0ksYUFBYUMsT0FBTyxFQUFFO1FBRTVELElBQUlDLE9BQVlDLFFBQWFDLFVBQWVDLE1BQVdDO1FBQ3ZELElBQUlDLE9BQVlDO1FBQ2hCLElBQUlDLFFBQVE7WUFBRUMsR0FBRztZQUFHQyxHQUFHO1FBQUU7UUFDekIsSUFBSUMsV0FBZ0JDO1FBQ3BCLElBQUlDLFdBQWdCQztRQUNwQixJQUFJQyxpQkFBMkUsRUFBRTtRQUVqRix3Q0FBd0M7UUFDeEMsSUFBSUMsV0FBVztZQUFFUCxHQUFHO1lBQUdDLEdBQUc7WUFBR08sR0FBRztRQUFFLEVBQUcsaUNBQWlDOztRQUN0RSxJQUFJQyxVQUFVLENBQUMsT0FBUSwyQkFBMkI7O1FBQ2xELElBQUlDLFNBQVMsSUFBVSxTQUFTOztRQUNoQyxJQUFJQyxXQUFXLEtBQVEsK0JBQStCOztRQUN0RCxJQUFJQyxTQUFTO1lBQUVaLEdBQUc7WUFBSUMsR0FBRztZQUFJTyxHQUFHO1FBQUUsRUFBRyxrQkFBa0I7O1FBQ3ZELElBQUlLLGtCQUFrQjtZQUFFYixHQUFHO1lBQUdDLEdBQUc7WUFBR08sR0FBRztRQUFFLEVBQUcsbURBQW1EOztRQUMvRixJQUFJTSxVQUEyRyxFQUFFO1FBQ2pILElBQUlDLGdCQUFnQjtRQUNwQixJQUFJQyxpQkFBaUI7UUFDckIsSUFBSUMsVUFBZTtRQUNuQixJQUFJQyxnQkFBcUI7UUFDekIsSUFBSUMsd0JBQXdCLE1BQU8saURBQWlEOztRQUNwRixJQUFJQyxrQkFBa0I7UUFFdEIsZ0NBQWdDO1FBQ2hDLElBQU1DLGVBQWU7WUFDbkJDLFdBQVc7WUFDWEMsZ0JBQWdCO1lB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UUFDTGlULFdBQVU7UUFDVmpFLE9BQU87WUFBRWtFLFdBQVc7WUFBU2pFLFFBQVE7UUFBVTs7Ozs7O0FBR3JEO0dBOXpCZ0JsUDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9sYXlvdXQvUnViaWtzQ3ViZS50c3g/MzMwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuXG5leHBvcnQgZnVuY3Rpb24gUnViaWtzQ3ViZSgpIHtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFjb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICBsZXQgc2NlbmU6IGFueSwgY2FtZXJhOiBhbnksIHJlbmRlcmVyOiBhbnksIGN1YmU6IGFueSwgYW5pbWF0aW9uSWQ6IG51bWJlclxuICAgIGxldCBmbG9vcjogYW55LCBmbG9vckdlb21ldHJ5OiBhbnlcbiAgICBsZXQgbW91c2UgPSB7IHg6IDAsIHk6IDAgfVxuICAgIGxldCByYXljYXN0ZXI6IGFueSwgbW91c2VWZWN0b3I6IGFueVxuICAgIGxldCBwYXJ0aWNsZXM6IGFueSwgcGFydGljbGVTeXN0ZW06IGFueVxuICAgIGxldCB0cmFpbFBvc2l0aW9uczogQXJyYXk8eyB4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyLCBsaWZlOiBudW1iZXIgfT4gPSBbXVxuXG4gICAgLy8gUGh5c2ljcyB2YXJpYWJsZXMgLSBmcmVlLWZhbGxpbmcgY3ViZVxuICAgIGxldCB2ZWxvY2l0eSA9IHsgeDogMCwgeTogMCwgejogMCB9ICAvLyBXaWxsIHN0YXJ0IGZhbGxpbmcgaW1tZWRpYXRlbHlcbiAgICBsZXQgZ3Jhdml0eSA9IC0wLjAwMDUgIC8vIEdyYXZpdHkgZm9yIG5hdHVyYWwgZmFsbFxuICAgIGxldCBib3VuY2UgPSAwLjcgICAgICAgLy8gQm91bmN5XG4gICAgbGV0IGZyaWN0aW9uID0gMC45OCAgICAvLyBGcmljdGlvbiB0byBoZWxwIGN1YmUgc2V0dGxlXG4gICAgbGV0IGJvdW5kcyA9IHsgeDogMTIsIHk6IDEyLCB6OiA4IH0gIC8vIE1vdmVtZW50IGJvdW5kc1xuICAgIGxldCBkZWZhdWx0UG9zaXRpb24gPSB7IHg6IDgsIHk6IDQsIHo6IDAgfSAgLy8gRGVmYXVsdCBzdGFydGluZyBwb3NpdGlvbiAoZmxvYXRpbmcgYWJvdmUgZmxvb3IpXG4gICAgbGV0IHJpcHBsZXM6IEFycmF5PHsgeDogbnVtYmVyLCB6OiBudW1iZXIsIHRpbWU6IG51bWJlciwgc3RyZW5ndGg6IG51bWJlciwgcmluZ3M6IGFueVtdLCBwYXJ0aWNsZXM6IGFueVtdIH0+ID0gW11cbiAgICBsZXQgbGFzdENsaWNrVGltZSA9IDBcbiAgICBsZXQgbGFzdFJpcHBsZVRpbWUgPSAwXG4gICAgbGV0IGdzYXBSZWY6IGFueSA9IG51bGxcbiAgICBsZXQgZmxvb3JNYXRlcmlhbDogYW55ID0gbnVsbFxuICAgIGxldCBpc1JldHVybmluZ1RvUG9zaXRpb24gPSBmYWxzZSAgLy8gVHJhY2sgaWYgY3ViZSBpcyByZXR1cm5pbmcgdG8gZGVmYXVsdCBwb3NpdGlvblxuICAgIGxldCByZXR1cm5TdGFydFRpbWUgPSAwXG5cbiAgICAvLyBDaXJjdWl0IGJvYXJkIHdhdmUgcGFyYW1ldGVyc1xuICAgIGNvbnN0IHJpcHBsZVBhcmFtcyA9IHtcbiAgICAgIG1heFJhZGl1czogMTAuMCxcbiAgICAgIGV4cGFuc2lvblNwZWVkOiAyLjAsICAvLyBTbG93XG4gICAgICB3YXZlSGVpZ2h0OiAwLjA4LCAgICAgLy8gQmFyZWx5IG5vdGljZWFibGUgdmVydGljYWwgZGlzcGxhY2VtZW50XG4gICAgICByaW5nV2lkdGg6IDAuMzUsXG4gICAgICBlbWlzc2l2ZUdhaW46IDAuMywgICAgLy8gQnJpZ2h0ZXIgZm9yIGNpcmN1aXQgdHJhY2VzXG4gICAgICBoaWdobGlnaHRHYWluOiAwLjQsXG4gICAgICBncmlkU2NhbGU6IDAuNSwgICAgICAgLy8gR3JpZCBsaW5lIHNwYWNpbmcgKHNtYWxsZXIgPSBkZW5zZXIgZ3JpZClcbiAgICAgIHRyYWNlQm9vc3Q6IDAuNSwgICAgICAvLyBDaXJjdWl0IHRyYWNlIGJyaWdodG5lc3NcbiAgICAgIGFmdGVyZ2xvd0RlY2F5OiAwLjk0LFxuICAgICAgbm9pc2VTY2FsZTogMy4wLFxuICAgICAgbm9pc2VTY3JvbGxTcGVlZDogMS4yXG4gICAgfVxuXG5cblxuICAgIGNvbnN0IGluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgc2NlbmVcbiAgICAgIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKClcblxuICAgICAgLy8gQ3JlYXRlIGNhbWVyYSAocG9zaXRpb25lZCB0byBzaG93IGN1YmUgbmVhciB0aXRsZSBvbiByaWdodCBzaWRlKVxuICAgICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICAgIGNvbnN0IGN3ID0gY29udGFpbmVyPy5jbGllbnRXaWR0aCB8fCAwXG4gICAgICBjb25zdCBjaCA9IGNvbnRhaW5lcj8uY2xpZW50SGVpZ2h0IHx8IDBcbiAgICAgIGNvbnN0IHdpZHRoID0gY3cgPiAxMCA/IGN3IDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmlubmVyV2lkdGggOiA2MDApXG4gICAgICBjb25zdCBoZWlnaHQgPSBjaCA+IDEwID8gY2ggOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiA2MDApXG4gICAgICBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNjUsIHdpZHRoIC8gaGVpZ2h0LCAwLjEsIDEwMDApXG4gICAgICBjYW1lcmEucG9zaXRpb24uc2V0KDgsIDIsIDIwKVxuICAgICAgY2FtZXJhLmxvb2tBdCg4LCAwLCAwKVxuXG4gICAgICAvLyBTZXR1cCByYXljYXN0ZXIgZm9yIG1vdXNlIGludGVyYWN0aW9uXG4gICAgICByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKClcbiAgICAgIG1vdXNlVmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKVxuXG4gICAgICAvLyBDcmVhdGUgcmVuZGVyZXJcbiAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbnRpYWxpYXM6IHRydWUsIGFscGhhOiB0cnVlIH0pXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhNYXRoLm1pbih3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAyKSlcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodClcbiAgICAgIHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gdHJ1ZVxuICAgICAgY29udGFpbmVyUmVmLmN1cnJlbnQ/LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpXG5cbiAgICAgIC8vIENyZWF0ZSBSdWJpaydzIGN1YmUgZ3JvdXBcbiAgICAgIGN1YmUgPSBuZXcgVEhSRUUuR3JvdXAoKVxuXG4gICAgICAvLyBDcmVhdGUgM3gzeDMgZ3JpZCBvZiBjdWJlbGV0c1xuICAgICAgY29uc3Qgb2Zmc2V0cyA9IFstMSwgMCwgMV1cbiAgICAgIGNvbnN0IGdhcCA9IDAuMVxuICAgICAgbGV0IGluZGV4ID0gMFxuXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDM7IHgrKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDM7IHkrKykge1xuICAgICAgICAgIGZvciAobGV0IHogPSAwOyB6IDwgMzsgeisrKSB7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgwLjksIDAuOSwgMC45KVxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgZGFyayBtYXRlcmlhbHNcbiAgICAgICAgICAgIGNvbnN0IGlzVGV4dHVyZWQgPSBpbmRleCAlIDQgPT09IDBcbiAgICAgICAgICAgIGNvbnN0IHN1cmZhY2VUeXBlID0gTWF0aC5yYW5kb20oKVxuXG4gICAgICAgICAgICBsZXQgbWF0ZXJpYWxcbiAgICAgICAgICAgIGlmIChzdXJmYWNlVHlwZSA8IDAuMjUgJiYgaXNUZXh0dXJlZCkge1xuICAgICAgICAgICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICAgICAgICAgICAgY29sb3I6IDB4MmEyYTJhLFxuICAgICAgICAgICAgICAgIG1ldGFsbmVzczogMC42LFxuICAgICAgICAgICAgICAgIHJvdWdobmVzczogMC4yLFxuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLjAsXG4gICAgICAgICAgICAgICAgZW1pc3NpdmU6IDB4MTExMTExLFxuICAgICAgICAgICAgICAgIGVtaXNzaXZlSW50ZW5zaXR5OiAwLjE1XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN1cmZhY2VUeXBlIDwgMC41KSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogMHgxYTFhMWEsXG4gICAgICAgICAgICAgICAgbWV0YWxuZXNzOiAwLjYsXG4gICAgICAgICAgICAgICAgcm91Z2huZXNzOiAwLjIsXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMCxcbiAgICAgICAgICAgICAgICBlbWlzc2l2ZTogMHgxMTExMTEsXG4gICAgICAgICAgICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDAuMTVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VyZmFjZVR5cGUgPCAwLjc1KSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogMHgzMzMzMzMsXG4gICAgICAgICAgICAgICAgbWV0YWxuZXNzOiAwLjYsXG4gICAgICAgICAgICAgICAgcm91Z2huZXNzOiAwLjIsXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMCxcbiAgICAgICAgICAgICAgICBlbWlzc2l2ZTogMHgxMTExMTEsXG4gICAgICAgICAgICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDAuMTVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogMHgyNTI1MjUsXG4gICAgICAgICAgICAgICAgbWV0YWxuZXNzOiAwLjYsXG4gICAgICAgICAgICAgICAgcm91Z2huZXNzOiAwLjIsXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMCxcbiAgICAgICAgICAgICAgICBlbWlzc2l2ZTogMHgxMTExMTEsXG4gICAgICAgICAgICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDAuMTVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY3ViZWxldCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbClcbiAgICAgICAgICAgIGN1YmVsZXQucG9zaXRpb24uc2V0KFxuICAgICAgICAgICAgICBvZmZzZXRzW3hdICogKDAuOSArIGdhcCksXG4gICAgICAgICAgICAgIG9mZnNldHNbeV0gKiAoMC45ICsgZ2FwKSxcbiAgICAgICAgICAgICAgb2Zmc2V0c1t6XSAqICgwLjkgKyBnYXApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBjdWJlbGV0LmNhc3RTaGFkb3cgPSB0cnVlXG4gICAgICAgICAgICBjdWJlbGV0LnJlY2VpdmVTaGFkb3cgPSB0cnVlXG5cbiAgICAgICAgICAgIC8vIEFkZCB3aXJlZnJhbWUgZWRnZXNcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VzID0gbmV3IFRIUkVFLkVkZ2VzR2VvbWV0cnkoZ2VvbWV0cnkpXG4gICAgICAgICAgICBjb25zdCBsaW5lID0gbmV3IFRIUkVFLkxpbmVTZWdtZW50cyhcbiAgICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICAgIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweDRiNTU2MywgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuNCB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgY3ViZWxldC5hZGQobGluZSlcblxuICAgICAgICAgICAgY3ViZS5hZGQoY3ViZWxldClcbiAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUG9zaXRpb24gY3ViZSBhdCBkZWZhdWx0IGZsb2F0aW5nIHBvc2l0aW9uIC0gd2lsbCBzdGFydCBmYWxsaW5nIGltbWVkaWF0ZWx5XG4gICAgICBjdWJlLnBvc2l0aW9uLnNldChkZWZhdWx0UG9zaXRpb24ueCwgZGVmYXVsdFBvc2l0aW9uLnksIGRlZmF1bHRQb3NpdGlvbi56KVxuICAgICAgc2NlbmUuYWRkKGN1YmUpXG5cbiAgICAgIC8vIEVuc3VyZSBjdWJlIHJlbmRlcnMgYWZ0ZXIgZ3JpZCB0byBhdm9pZCBcInN1Ym1lcmdpbmdcIiB2aXN1YWxzXG4gICAgICBjdWJlLnRyYXZlcnNlKChvOiBhbnkpID0+IHsgby5yZW5kZXJPcmRlciA9IDEgfSlcblxuICAgICAgLy8gQWRkIGludmlzaWJsZSBib3VuZGluZyBzcGhlcmUgZm9yIGVhc2llciBjbGlja2luZ1xuICAgICAgY29uc3QgaGl0U3BoZXJlR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMi4wLCAxNiwgMTYpXG4gICAgICBjb25zdCBoaXRTcGhlcmVNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSlcbiAgICAgIGNvbnN0IGhpdFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKGhpdFNwaGVyZUdlb21ldHJ5LCBoaXRTcGhlcmVNYXRlcmlhbClcbiAgICAgIGhpdFNwaGVyZS5uYW1lID0gJ2hpdFRhcmdldCdcbiAgICAgIGN1YmUuYWRkKGhpdFNwaGVyZSlcblxuICAgICAgY29uc29sZS5sb2coJ/CfjrIgQ3ViZSBpbml0aWFsaXplZCBhdCBwb3NpdGlvbjonLCBkZWZhdWx0UG9zaXRpb24sICctIGZyZWUtZmFsbGluZyBlbmFibGVkJylcblxuICAgICAgLy8gQ3JlYXRlIGZsb29yIHdpdGggY2lyY3VpdCBib2FyZCBzaGFkZXJcbiAgICAgIGNvbnN0IGZsb29yU2l6ZSA9IDEwMFxuICAgICAgY29uc3QgZmxvb3JTZWdtZW50cyA9IDMwMFxuICAgICAgZmxvb3JHZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KGZsb29yU2l6ZSwgZmxvb3JTaXplLCBmbG9vclNlZ21lbnRzLCBmbG9vclNlZ21lbnRzKVxuICAgICAgZmxvb3JHZW9tZXRyeS5yb3RhdGVYKC1NYXRoLlBJIC8gMilcblxuICAgICAgLy8gQ3VzdG9tIHNoYWRlciBtYXRlcmlhbCBmb3IgY2lyY3VpdCBib2FyZCBlZmZlY3RcbiAgICAgIGZsb29yTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHRpbWU6IHsgdmFsdWU6IDAgfSxcbiAgICAgICAgICBncmlkU2NhbGU6IHsgdmFsdWU6IHJpcHBsZVBhcmFtcy5ncmlkU2NhbGUgfSxcbiAgICAgICAgICBiYXNlQ29sb3I6IHsgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweDBkMTExNykgfSxcbiAgICAgICAgICBncmlkQ29sb3I6IHsgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweDJhM2Y1ZikgfSwgIC8vIERhcmtlciBibHVlIGdyaWQgbGluZXNcbiAgICAgICAgICBnbG93Q29sb3I6IHsgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweDRhOWVmZikgfSwgIC8vIEJyaWdodCBibHVlIGZvciBhY3RpdmF0ZWQgdHJhY2VzXG4gICAgICAgICAgcmlwcGxlUG9zaXRpb25zOiB7IHZhbHVlOiBbbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKV0gfSxcbiAgICAgICAgICByaXBwbGVSYWRpaTogeyB2YWx1ZTogWzAsIDAsIDBdIH0sXG4gICAgICAgICAgcmlwcGxlU3RyZW5ndGhzOiB7IHZhbHVlOiBbMCwgMCwgMF0gfVxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGBcbiAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcblxuICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIHZVdiA9IHV2O1xuICAgICAgICAgICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xuICAgICAgICAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XG4gICAgICAgICAgdW5pZm9ybSBmbG9hdCBncmlkU2NhbGU7XG4gICAgICAgICAgdW5pZm9ybSB2ZWMzIGJhc2VDb2xvcjtcbiAgICAgICAgICB1bmlmb3JtIHZlYzMgZ3JpZENvbG9yO1xuICAgICAgICAgIHVuaWZvcm0gdmVjMyBnbG93Q29sb3I7XG4gICAgICAgICAgdW5pZm9ybSB2ZWMzIHJpcHBsZVBvc2l0aW9uc1szXTtcbiAgICAgICAgICB1bmlmb3JtIGZsb2F0IHJpcHBsZVJhZGlpWzNdO1xuICAgICAgICAgIHVuaWZvcm0gZmxvYXQgcmlwcGxlU3RyZW5ndGhzWzNdO1xuXG4gICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG5cbiAgICAgICAgICAvLyBDaXJjdWl0IGJvYXJkIGdyaWQgcGF0dGVyblxuICAgICAgICAgIGZsb2F0IGdyaWRQYXR0ZXJuKHZlYzIgcG9zKSB7XG4gICAgICAgICAgICB2ZWMyIGdyaWQgPSBhYnMoZnJhY3QocG9zIC8gZ3JpZFNjYWxlIC0gMC41KSAtIDAuNSk7XG4gICAgICAgICAgICBmbG9hdCBsaW5lID0gbWluKGdyaWQueCwgZ3JpZC55KTtcbiAgICAgICAgICAgIHJldHVybiBzbW9vdGhzdGVwKDAuMDIsIDAuMCwgbGluZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2lyY3VpdCB0cmFjZSBwYXR0ZXJuIChtb3JlIGNvbXBsZXgpXG4gICAgICAgICAgZmxvYXQgdHJhY2VQYXR0ZXJuKHZlYzIgcG9zKSB7XG4gICAgICAgICAgICB2ZWMyIHAgPSBwb3MgLyBncmlkU2NhbGU7XG5cbiAgICAgICAgICAgIC8vIEhvcml6b250YWwgYW5kIHZlcnRpY2FsIHRyYWNlc1xuICAgICAgICAgICAgZmxvYXQgaCA9IHN0ZXAoMC44NSwgZnJhY3QocC55KSk7XG4gICAgICAgICAgICBmbG9hdCB2ID0gc3RlcCgwLjg1LCBmcmFjdChwLngpKTtcblxuICAgICAgICAgICAgLy8gRGlhZ29uYWwgdHJhY2VzIChsZXNzIGZyZXF1ZW50KVxuICAgICAgICAgICAgZmxvYXQgZDEgPSBzdGVwKDAuOTIsIGZyYWN0KChwLnggKyBwLnkpICogMC41KSk7XG4gICAgICAgICAgICBmbG9hdCBkMiA9IHN0ZXAoMC45MiwgZnJhY3QoKHAueCAtIHAueSkgKiAwLjUpKTtcblxuICAgICAgICAgICAgcmV0dXJuIG1heChtYXgoaCwgdiksIG1heChkMSwgZDIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICB2ZWMyIHBvcyA9IHZXb3JsZFBvc2l0aW9uLnh6O1xuXG4gICAgICAgICAgICAvLyBCYXNlIGNpcmN1aXQgYm9hcmQgcGF0dGVyblxuICAgICAgICAgICAgZmxvYXQgZ3JpZCA9IGdyaWRQYXR0ZXJuKHBvcyk7XG4gICAgICAgICAgICBmbG9hdCB0cmFjZXMgPSB0cmFjZVBhdHRlcm4ocG9zKTtcbiAgICAgICAgICAgIGZsb2F0IHBhdHRlcm4gPSBtYXgoZ3JpZCAqIDAuNCwgdHJhY2VzKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHJpcHBsZSBhY3RpdmF0aW9uXG4gICAgICAgICAgICBmbG9hdCBhY3RpdmF0aW9uID0gMC4wO1xuICAgICAgICAgICAgZm9yKGludCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICBpZihyaXBwbGVTdHJlbmd0aHNbaV0gPiAwLjApIHtcbiAgICAgICAgICAgICAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UodldvcmxkUG9zaXRpb24ueHosIHJpcHBsZVBvc2l0aW9uc1tpXS54eik7XG4gICAgICAgICAgICAgICAgZmxvYXQgcmlwcGxlRWRnZSA9IGFicyhkaXN0IC0gcmlwcGxlUmFkaWlbaV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWN0aXZhdGUgdHJhY2VzIG5lYXIgdGhlIHJpcHBsZSBlZGdlXG4gICAgICAgICAgICAgICAgaWYocmlwcGxlRWRnZSA8IDAuOCkge1xuICAgICAgICAgICAgICAgICAgZmxvYXQgZWRnZUZhY3RvciA9IDEuMCAtIChyaXBwbGVFZGdlIC8gMC44KTtcbiAgICAgICAgICAgICAgICAgIGFjdGl2YXRpb24gPSBtYXgoYWN0aXZhdGlvbiwgZWRnZUZhY3RvciAqIHJpcHBsZVN0cmVuZ3Roc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBhY3RpdmF0ZSB0cmFjZXMgdGhhdCBoYXZlIGJlZW4gcGFzc2VkIGJ5IHRoZSB3YXZlIChhZnRlcmdsb3cpXG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IHJpcHBsZVJhZGlpW2ldKSB7XG4gICAgICAgICAgICAgICAgICBmbG9hdCBhZnRlcmdsb3cgPSAoMS4wIC0gZGlzdCAvIHJpcHBsZVJhZGlpW2ldKSAqIDAuMTUgKiByaXBwbGVTdHJlbmd0aHNbaV07XG4gICAgICAgICAgICAgICAgICBhY3RpdmF0aW9uID0gbWF4KGFjdGl2YXRpb24sIGFmdGVyZ2xvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1peCBjb2xvcnMgYmFzZWQgb24gYWN0aXZhdGlvblxuICAgICAgICAgICAgdmVjMyBiYXNlUGF0dGVybiA9IG1peChiYXNlQ29sb3IsIGdyaWRDb2xvciwgcGF0dGVybik7XG4gICAgICAgICAgICB2ZWMzIGZpbmFsQ29sb3IgPSBtaXgoYmFzZVBhdHRlcm4sIGdsb3dDb2xvciwgYWN0aXZhdGlvbiAqIHBhdHRlcm4pO1xuXG4gICAgICAgICAgICAvLyBNYWtlIGZsb29yIG1vc3RseSB0cmFuc3BhcmVudCBidXQgc2hvdyBjaXJjdWl0IHBhdHRlcm5cbiAgICAgICAgICAgIGZsb2F0IGFscGhhID0gcGF0dGVybiAqIDAuMiArIGFjdGl2YXRpb24gKiBwYXR0ZXJuICogMC43O1xuXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGZpbmFsQ29sb3IsIGFscGhhKTtcbiAgICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXG4gICAgICB9KVxuXG4gICAgICBmbG9vciA9IG5ldyBUSFJFRS5NZXNoKGZsb29yR2VvbWV0cnksIGZsb29yTWF0ZXJpYWwpXG4gICAgICBmbG9vci5wb3NpdGlvbi5zZXQoOCwgLTQsIDApXG4gICAgICBmbG9vci5yZWNlaXZlU2hhZG93ID0gZmFsc2VcbiAgICAgIHNjZW5lLmFkZChmbG9vcilcblxuICAgICAgY29uc29sZS5sb2coJ+KchSBDaXJjdWl0IGJvYXJkIGZsb29yIGNyZWF0ZWQgd2l0aCBzaGFkZXInKVxuXG4gICAgICAvLyBEYXJrZXIsIG1vcmUgYXRtb3NwaGVyaWMgbGlnaHRpbmcgZm9yIGNpcmN1aXQgYm9hcmQgYWVzdGhldGljXG4gICAgICBjb25zdCBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4MmEyZjNhLCAwLjUpXG4gICAgICBzY2VuZS5hZGQoYW1iaWVudExpZ2h0KVxuXG4gICAgICBjb25zdCBkaXJlY3Rpb25hbExpZ2h0MSA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAwLjUpXG4gICAgICBkaXJlY3Rpb25hbExpZ2h0MS5wb3NpdGlvbi5zZXQoMTAsIDEwLCAxMClcbiAgICAgIHNjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0MSlcblxuICAgICAgY29uc3QgZGlyZWN0aW9uYWxMaWdodDIgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweDQwNDA1MCwgMC4yKVxuICAgICAgZGlyZWN0aW9uYWxMaWdodDIucG9zaXRpb24uc2V0KC0xMCwgLTEwLCAtMTApXG4gICAgICBzY2VuZS5hZGQoZGlyZWN0aW9uYWxMaWdodDIpXG5cbiAgICAgIC8vIFN1YnRsZSBibHVlIGFjY2VudCBsaWdodHMgZm9yIGNpcmN1aXQgYm9hcmQgZ2xvd1xuICAgICAgY29uc3QgcG9pbnRMaWdodDEgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCgweDAwNjZhYSwgMS4wLCAxMDApXG4gICAgICBwb2ludExpZ2h0MS5wb3NpdGlvbi5zZXQoOCwgNSwgMTApXG4gICAgICBzY2VuZS5hZGQocG9pbnRMaWdodDEpXG5cbiAgICAgIGNvbnN0IHBvaW50TGlnaHQyID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoMHgwMDQ0ODgsIDAuOCwgMTAwKVxuICAgICAgcG9pbnRMaWdodDIucG9zaXRpb24uc2V0KDgsIC0zLCAxMClcbiAgICAgIHNjZW5lLmFkZChwb2ludExpZ2h0MilcblxuICAgICAgLy8gQWRkIHJpbSBsaWdodHMgZm9yIGRyYW1hdGljIGVmZmVjdFxuICAgICAgY29uc3QgcmltTGlnaHQxID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoMHgwMDMzNjYsIDAuNCwgMTAwKVxuICAgICAgcmltTGlnaHQxLnBvc2l0aW9uLnNldCgwLCAxMCwgLTEwKVxuICAgICAgLy8gR1NBUCBsb2FkZXIgYW5kIGludHJvIGFuaW1hdGlvbnNcbiAgICAgIGNvbnN0IGxvYWRHU0FQID0gKCk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cgYXMgYW55KS5nc2FwKSByZXR1cm4gcmVzb2x2ZSgod2luZG93IGFzIGFueSkuZ3NhcClcbiAgICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcblxuXG4gICAgICAgICAgcy5zcmMgPSAnaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvZ3NhcC8zLjEyLjIvZ3NhcC5taW4uanMnXG4gICAgICAgICAgcy5hc3luYyA9IHRydWVcbiAgICAgICAgICBzLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKHdpbmRvdyBhcyBhbnkpLmdzYXApXG4gICAgICAgICAgcy5vbmVycm9yID0gcmVqZWN0XG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBnc2FwUmVmID0gYXdhaXQgbG9hZEdTQVAoKVxuICAgICAgICAvLyBTbW9vdGggY2FtZXJhIGludHJvXG4gICAgICAgIGdzYXBSZWYuZnJvbVRvKGNhbWVyYS5wb3NpdGlvbiwgeyB6OiBjYW1lcmEucG9zaXRpb24ueiArIDQsIHk6IGNhbWVyYS5wb3NpdGlvbi55IC0gMC44IH0sIHtcbiAgICAgICAgICB6OiBjYW1lcmEucG9zaXRpb24ueiwgeTogY2FtZXJhLnBvc2l0aW9uLnksIGR1cmF0aW9uOiAxLjIsIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBHU0FQIGZhaWxlZCB0byBsb2FkOyBwcm9jZWVkIHdpdGhvdXQgYW5pbWF0ZWQgaW50cm9cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHVsc2VGbG9vckdsb3cgPSAoc3RyZW5ndGg6IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoIWdzYXBSZWYgfHwgIWZsb29yTWF0ZXJpYWwpIHJldHVyblxuICAgICAgICBjb25zdCB0YXJnZXRJbnRlbnNpdHkgPSBNYXRoLm1pbigwLjgsIDAuMyArIHN0cmVuZ3RoICogMS4yKVxuICAgICAgICAvLyBQdWxzZSB0aGUgZW1pc3NpdmUgaW50ZW5zaXR5IHRvIHJldmVhbCBjaXJjdWl0IHBhdHRlcm5cbiAgICAgICAgZ3NhcFJlZi50byhmbG9vck1hdGVyaWFsLCB7XG4gICAgICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IHRhcmdldEludGVuc2l0eSxcbiAgICAgICAgICBkdXJhdGlvbjogMC4xNSxcbiAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCcsXG4gICAgICAgICAgeW95bzogdHJ1ZSxcbiAgICAgICAgICByZXBlYXQ6IDFcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgc2NlbmUuYWRkKHJpbUxpZ2h0MSlcblxuICAgICAgY29uc3QgcmltTGlnaHQyID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoMHgwMDQ0ODgsIDAuMywgMTAwKVxuICAgICAgcmltTGlnaHQyLnBvc2l0aW9uLnNldCgxMCwgLTUsIDApXG4gICAgICBzY2VuZS5hZGQocmltTGlnaHQyKVxuXG4gICAgICAvLyBDcmVhdGUgcGFydGljbGUgc3lzdGVtIGZvciBpbXBhY3QgZWZmZWN0c1xuICAgICAgY29uc3QgcGFydGljbGVDb3VudCA9IDUwMFxuICAgICAgY29uc3QgcGFydGljbGVHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpXG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHBhcnRpY2xlQ291bnQgKiAzKVxuICAgICAgY29uc3QgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShwYXJ0aWNsZUNvdW50ICogMylcbiAgICAgIGNvbnN0IHNpemVzID0gbmV3IEZsb2F0MzJBcnJheShwYXJ0aWNsZUNvdW50KVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2xlQ291bnQ7IGkrKykge1xuICAgICAgICBwb3NpdGlvbnNbaSAqIDNdID0gMFxuICAgICAgICBwb3NpdGlvbnNbaSAqIDMgKyAxXSA9IDBcbiAgICAgICAgcG9zaXRpb25zW2kgKiAzICsgMl0gPSAwXG5cbiAgICAgICAgY29sb3JzW2kgKiAzXSA9IDAuMlxuICAgICAgICBjb2xvcnNbaSAqIDMgKyAxXSA9IDAuNVxuICAgICAgICBjb2xvcnNbaSAqIDMgKyAyXSA9IDEuMFxuXG4gICAgICAgIHNpemVzW2ldID0gTWF0aC5yYW5kb20oKSAqIDAuMSArIDAuMDVcbiAgICAgIH1cblxuICAgICAgcGFydGljbGVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKVxuICAgICAgcGFydGljbGVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKVxuICAgICAgcGFydGljbGVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3NpemUnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHNpemVzLCAxKSlcblxuICAgICAgY29uc3QgcGFydGljbGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7XG4gICAgICAgIHNpemU6IDAuMSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIG9wYWNpdHk6IDAuNixcbiAgICAgICAgdmVydGV4Q29sb3JzOiB0cnVlLFxuICAgICAgICBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyxcbiAgICAgICAgc2l6ZUF0dGVudWF0aW9uOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICBwYXJ0aWNsZVN5c3RlbSA9IG5ldyBUSFJFRS5Qb2ludHMocGFydGljbGVHZW9tZXRyeSwgcGFydGljbGVNYXRlcmlhbClcbiAgICAgIHNjZW5lLmFkZChwYXJ0aWNsZVN5c3RlbSlcblxuXG5cbiAgICAgIGNvbnN0IGNyZWF0ZVJpcHBsZSA9ICh4OiBudW1iZXIsIHo6IG51bWJlciwgc3RyZW5ndGg6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBub3cgPSAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyA/IHBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKSlcbiAgICAgICAgaWYgKG5vdyAtIGxhc3RSaXBwbGVUaW1lIDwgMTIwKSB7XG4gICAgICAgICAgcmV0dXJuIC8vIHRocm90dGxlIHRvIHByZXZlbnQgaGF5d2lyZSBvbiByYXBpZCBib3VuY2VzXG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJpcHBsZVRpbWUgPSBub3dcblxuICAgICAgICAvLyBDcmVhdGUgdWx0cmEtc3VidGxlIHJlYWxpc3RpYyB3YXZlIHJpcHBsZVxuICAgICAgICBjb25zdCBzID0gTWF0aC5taW4oMS4wLCAwLjQgKyBzdHJlbmd0aCAqIDAuNilcblxuICAgICAgICAvLyBDb252ZXJ0IGZsb29yLWxvY2FsIGNvb3JkaW5hdGVzIHRvIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAgICAgIGNvbnN0IHdvcmxkWCA9IHggKyBmbG9vci5wb3NpdGlvbi54XG4gICAgICAgIGNvbnN0IHdvcmxkWiA9IHpcbiAgICAgICAgY29uc3Qgd29ybGRZID0gZmxvb3IucG9zaXRpb24ueVxuXG4gICAgICAgIC8vIENyZWF0ZSByZWFsaXN0aWMgd2F2ZSByaXBwbGUgLSB2ZXJ5IHRoaW4sIGJhcmVseSB2aXNpYmxlXG4gICAgICAgIGNvbnN0IHJpbmdzOiBhbnlbXSA9IFtdXG4gICAgICAgIGNvbnN0IHBhcnRpY2xlczogYW55W10gPSBbXVxuXG4gICAgICAgIC8vIERhcmtlciwgbW9yZSB2aXNpYmxlIHdhdmUgY3Jlc3RcbiAgICAgICAgY29uc3Qgd2F2ZUdlbyA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KDAuNSwgMC4wMzUsIDgsIDY0KSAgLy8gU2xpZ2h0bHkgdGhpY2tlclxuICAgICAgICBjb25zdCB3YXZlTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICBjb2xvcjogMHgzYTZlYTUsICAvLyBEYXJrZXIgYmx1ZSAobW9yZSB2aXNpYmxlKVxuICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgIG9wYWNpdHk6IDAuMjUsICAgIC8vIE1vcmUgdmlzaWJsZVxuICAgICAgICAgIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGUsXG4gICAgICAgICAgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmdcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3Qgd2F2ZSA9IG5ldyBUSFJFRS5NZXNoKHdhdmVHZW8sIHdhdmVNYXQpXG4gICAgICAgIHdhdmUucm90YXRpb24ueCA9IE1hdGguUEkgLyAyXG4gICAgICAgIHdhdmUucG9zaXRpb24uc2V0KHdvcmxkWCwgd29ybGRZLCB3b3JsZFopXG4gICAgICAgIHNjZW5lLmFkZCh3YXZlKVxuICAgICAgICByaW5ncy5wdXNoKHsgbWVzaDogd2F2ZSwgdHlwZTogJ21haW4nLCBpbml0aWFsWTogd29ybGRZIH0pXG5cbiAgICAgICAgcmlwcGxlcy5wdXNoKHsgeCwgeiwgdGltZTogMCwgc3RyZW5ndGg6IHMsIHJpbmdzLCBwYXJ0aWNsZXMgfSlcblxuICAgICAgICAvLyBMaW1pdCB0byAzIGNvbmN1cnJlbnQgd2F2ZXNcbiAgICAgICAgaWYgKHJpcHBsZXMubGVuZ3RoID4gMykge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSByaXBwbGVzLnNoaWZ0KClcbiAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgcmVtb3ZlZC5yaW5ncy5mb3JFYWNoKChyOiBhbnkpID0+IHNjZW5lLnJlbW92ZShyLm1lc2gpKVxuICAgICAgICAgICAgcmVtb3ZlZC5wYXJ0aWNsZXMuZm9yRWFjaCgocDogYW55KSA9PiBzY2VuZS5yZW1vdmUocC5zeXN0ZW0pKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4yKIFVsdHJhLXN1YnRsZSB3YXZlIHJpcHBsZSBjcmVhdGVkIGF0OicsIHdvcmxkWCwgd29ybGRZLCB3b3JsZFopXG4gICAgICB9XG5cbiAgICAgIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBjaXJjdWl0IGJvYXJkIHdhdmUgZWZmZWN0XG4gICAgICBjb25zdCB1cGRhdGVGbG9vclJpcHBsZXMgPSAoKSA9PiB7XG4gICAgICAgIC8vIFVwZGF0ZSBzaGFkZXIgdW5pZm9ybXMgd2l0aCByaXBwbGUgZGF0YVxuICAgICAgICBjb25zdCBwb3NpdGlvbnM6IGFueVtdID0gW11cbiAgICAgICAgY29uc3QgcmFkaWk6IG51bWJlcltdID0gW11cbiAgICAgICAgY29uc3Qgc3RyZW5ndGhzOiBudW1iZXJbXSA9IFtdXG5cbiAgICAgICAgcmlwcGxlcyA9IHJpcHBsZXMuZmlsdGVyKChyaXBwbGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmlwcGxlLnRpbWUgKz0gMC4wMTYgIC8vIH42MGZwc1xuXG4gICAgICAgICAgLy8gU2xvdyBleHBhbnNpb25cbiAgICAgICAgICBjb25zdCBleHBhbnNpb25TcGVlZCA9IHJpcHBsZVBhcmFtcy5leHBhbnNpb25TcGVlZCAgLy8gMi4wIHVuaXRzL3NlY1xuICAgICAgICAgIGNvbnN0IG1heFJhZGl1cyA9IHJpcHBsZVBhcmFtcy5tYXhSYWRpdXMgIC8vIDEwLjAgdW5pdHNcbiAgICAgICAgICBjb25zdCB3YXZlSGVpZ2h0ID0gcmlwcGxlUGFyYW1zLndhdmVIZWlnaHQgIC8vIDAuMDggdW5pdHMgdmVydGljYWxcbiAgICAgICAgICBjb25zdCBjdXJyZW50UmFkaXVzID0gcmlwcGxlLnRpbWUgKiBleHBhbnNpb25TcGVlZFxuXG4gICAgICAgICAgLy8gNSBzZWNvbmQgdG90YWwgZHVyYXRpb24gLSB2ZXJ5IHNsb3dcbiAgICAgICAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gNS4wXG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSByaXBwbGUudGltZSAvIHRvdGFsRHVyYXRpb25cblxuICAgICAgICAgIC8vIFZlcnkgc21vb3RoIGVhc2Utb3V0IGZvciBnZW50bGUgZXhwYW5zaW9uXG4gICAgICAgICAgY29uc3QgZWFzZU91dCA9IDEgLSBNYXRoLnBvdygxIC0gTWF0aC5taW4ocHJvZ3Jlc3MsIDEpLCAyKVxuXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHN0cmVuZ3RoIGZvciBzaGFkZXJcbiAgICAgICAgICBsZXQgc3RyZW5ndGggPSAwXG4gICAgICAgICAgaWYgKHByb2dyZXNzIDwgMC4zKSB7XG4gICAgICAgICAgICBzdHJlbmd0aCA9IChwcm9ncmVzcyAvIDAuMykgKiAwLjhcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyZXNzIDwgMC42KSB7XG4gICAgICAgICAgICBzdHJlbmd0aCA9IDAuOFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlbmd0aCA9IDAuOCAqICgxIC0gKHByb2dyZXNzIC0gMC42KSAvIDAuNClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdG9yZSByaXBwbGUgZGF0YSBmb3Igc2hhZGVyICh1cCB0byAzIHJpcHBsZXMpXG4gICAgICAgICAgaWYgKGluZGV4IDwgMykge1xuICAgICAgICAgICAgY29uc3Qgd29ybGRYID0gcmlwcGxlLnggKyBmbG9vci5wb3NpdGlvbi54XG4gICAgICAgICAgICBjb25zdCB3b3JsZFogPSByaXBwbGUuelxuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMod29ybGRYLCBmbG9vci5wb3NpdGlvbi55LCB3b3JsZFopKVxuICAgICAgICAgICAgcmFkaWkucHVzaChjdXJyZW50UmFkaXVzICogZWFzZU91dClcbiAgICAgICAgICAgIHN0cmVuZ3Rocy5wdXNoKHN0cmVuZ3RoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFuaW1hdGUgdGhlIHdhdmUgcmluZ1xuICAgICAgICAgIHJpcHBsZS5yaW5ncy5mb3JFYWNoKChyaW5nT2JqOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJpbmcgPSByaW5nT2JqLm1lc2hcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxZID0gcmluZ09iai5pbml0aWFsWVxuXG4gICAgICAgICAgICAvLyBTY2FsZSBvdXR3YXJkIHNsb3dseVxuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSAxICsgY3VycmVudFJhZGl1cyAqIGVhc2VPdXQgKiAxLjBcbiAgICAgICAgICAgIHJpbmcuc2NhbGUuc2V0KHNjYWxlLCBzY2FsZSwgc2NhbGUpXG5cbiAgICAgICAgICAgIC8vIFN1YnRsZSB2ZXJ0aWNhbCB3YXZlIG1vdGlvblxuICAgICAgICAgICAgbGV0IGhlaWdodE9mZnNldCA9IDBcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDAuMzUpIHtcbiAgICAgICAgICAgICAgaGVpZ2h0T2Zmc2V0ID0gKHByb2dyZXNzIC8gMC4zNSkgKiB3YXZlSGVpZ2h0XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyZXNzIDwgMC41NSkge1xuICAgICAgICAgICAgICBoZWlnaHRPZmZzZXQgPSB3YXZlSGVpZ2h0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWlnaHRPZmZzZXQgPSB3YXZlSGVpZ2h0ICogKDEgLSAocHJvZ3Jlc3MgLSAwLjU1KSAvIDAuNDUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJpbmcucG9zaXRpb24ueSA9IGluaXRpYWxZICsgaGVpZ2h0T2Zmc2V0XG5cbiAgICAgICAgICAgIC8vIE9wYWNpdHkgYW5pbWF0aW9uXG4gICAgICAgICAgICBsZXQgb3BhY2l0eSA9IDBcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDAuMykge1xuICAgICAgICAgICAgICBvcGFjaXR5ID0gKHByb2dyZXNzIC8gMC4zKSAqIDAuMjVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvZ3Jlc3MgPCAwLjYpIHtcbiAgICAgICAgICAgICAgb3BhY2l0eSA9IDAuMjVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wYWNpdHkgPSAwLjI1ICogKDEgLSAocHJvZ3Jlc3MgLSAwLjYpIC8gMC40KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByaW5nLm1hdGVyaWFsLm9wYWNpdHkgPSBNYXRoLm1heCgwLCBvcGFjaXR5KVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICAvLyBSZW1vdmUgd2hlbiBjb21wbGV0ZVxuICAgICAgICAgIGlmIChyaXBwbGUudGltZSA+PSB0b3RhbER1cmF0aW9uIHx8IGN1cnJlbnRSYWRpdXMgPiBtYXhSYWRpdXMpIHtcbiAgICAgICAgICAgIHJpcHBsZS5yaW5ncy5mb3JFYWNoKChyOiBhbnkpID0+IHNjZW5lLnJlbW92ZShyLm1lc2gpKVxuICAgICAgICAgICAgcmlwcGxlLnBhcnRpY2xlcy5mb3JFYWNoKChwOiBhbnkpID0+IHNjZW5lLnJlbW92ZShwLnN5c3RlbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBVcGRhdGUgZmxvb3Igc2hhZGVyIHVuaWZvcm1zXG4gICAgICAgIGlmIChmbG9vciAmJiBmbG9vci5tYXRlcmlhbCAmJiBmbG9vci5tYXRlcmlhbC51bmlmb3Jtcykge1xuICAgICAgICAgIC8vIFBhZCBhcnJheXMgdG8gbGVuZ3RoIDNcbiAgICAgICAgICB3aGlsZSAocG9zaXRpb25zLmxlbmd0aCA8IDMpIHBvc2l0aW9ucy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApKVxuICAgICAgICAgIHdoaWxlIChyYWRpaS5sZW5ndGggPCAzKSByYWRpaS5wdXNoKDApXG4gICAgICAgICAgd2hpbGUgKHN0cmVuZ3Rocy5sZW5ndGggPCAzKSBzdHJlbmd0aHMucHVzaCgwKVxuXG4gICAgICAgICAgZmxvb3IubWF0ZXJpYWwudW5pZm9ybXMucmlwcGxlUG9zaXRpb25zLnZhbHVlID0gcG9zaXRpb25zXG4gICAgICAgICAgZmxvb3IubWF0ZXJpYWwudW5pZm9ybXMucmlwcGxlUmFkaWkudmFsdWUgPSByYWRpaVxuICAgICAgICAgIGZsb29yLm1hdGVyaWFsLnVuaWZvcm1zLnJpcHBsZVN0cmVuZ3Rocy52YWx1ZSA9IHN0cmVuZ3Roc1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgLy8gTW91c2UgaW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAgICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSByZW5kZXJlci5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIG1vdXNlLnggPSAoKGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQpIC8gcmVjdC53aWR0aCkgKiAyIC0gMVxuICAgICAgICBtb3VzZS55ID0gLSgoZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAvIHJlY3QuaGVpZ2h0KSAqIDIgKyAxXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaG92ZXJpbmcgb3ZlciBjdWJlXG4gICAgICAgIG1vdXNlVmVjdG9yLnggPSBtb3VzZS54XG4gICAgICAgIG1vdXNlVmVjdG9yLnkgPSBtb3VzZS55XG4gICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlVmVjdG9yLCBjYW1lcmEpXG4gICAgICAgIGNvbnN0IGludGVyc2VjdHMgPSByYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KGN1YmUsIHRydWUpXG5cbiAgICAgICAgLy8gQ2hhbmdlIGN1cnNvciB3aGVuIGhvdmVyaW5nXG4gICAgICAgIGlmIChpbnRlcnNlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZW5kZXJlci5kb21FbGVtZW50LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlcmVyLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2dyYWInXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25Nb3VzZUNsaWNrID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxuXG4gICAgICAgIC8vIFJlZHVjZWQgZGVib3VuY2UgdGltZSBmb3IgYmV0dGVyIHJlc3BvbnNpdmVuZXNzXG4gICAgICAgIGlmIChjdXJyZW50VGltZSAtIGxhc3RDbGlja1RpbWUgPCAyMDApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2xpY2tUaW1lID0gY3VycmVudFRpbWVcblxuICAgICAgICAvLyBDYWxjdWxhdGUgbW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gY2FudmFzXG4gICAgICAgIGNvbnN0IHJlY3QgPSByZW5kZXJlci5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIG1vdXNlVmVjdG9yLnggPSAoKGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQpIC8gcmVjdC53aWR0aCkgKiAyIC0gMVxuICAgICAgICBtb3VzZVZlY3Rvci55ID0gLSgoZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAvIHJlY3QuaGVpZ2h0KSAqIDIgKyAxXG5cbiAgICAgICAgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEobW91c2VWZWN0b3IsIGNhbWVyYSlcblxuICAgICAgICAvLyBDaGVjayBpbnRlcnNlY3Rpb24gd2l0aCBjdWJlIGFuZCBhbGwgaXRzIGNoaWxkcmVuIChpbmNsdWRpbmcgaW52aXNpYmxlIGJvdW5kaW5nIHNwaGVyZSlcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0cyA9IHJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QoY3ViZSwgdHJ1ZSlcblxuICAgICAgICBjb25zb2xlLmxvZygn8J+OryBDbGljayBkZXRlY3RlZCEgSW50ZXJzZWN0czonLCBpbnRlcnNlY3RzLmxlbmd0aCwgJ0N1YmUgcG9zaXRpb246JywgY3ViZS5wb3NpdGlvbilcblxuICAgICAgICAvLyBPTkxZIHRyaWdnZXIgaWYgY2xpY2tpbmcgZGlyZWN0bHkgb24gdGhlIGN1YmVcbiAgICAgICAgaWYgKGludGVyc2VjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgSElUISBDdWJlIGNsaWNrZWQgYXQ6JywgaW50ZXJzZWN0c1swXS5wb2ludClcblxuICAgICAgICAgIC8vIENhbmNlbCBhbnkgb25nb2luZyByZXR1cm4gYW5pbWF0aW9uXG4gICAgICAgICAgaXNSZXR1cm5pbmdUb1Bvc2l0aW9uID0gZmFsc2VcbiAgICAgICAgICByZXR1cm5TdGFydFRpbWUgPSAwXG5cbiAgICAgICAgICAvLyBCb3VuY2UgdGhlIGN1YmUgd2l0aCBhIHF1aWNrIGltcHVsc2VcbiAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgICAgICAgY29uc3QgY2xpY2tQb2ludCA9IGludGVyc2VjdHNbMF0ucG9pbnRcbiAgICAgICAgICBkaXJlY3Rpb24uc3ViVmVjdG9ycyhjdWJlLnBvc2l0aW9uLCBjbGlja1BvaW50KS5ub3JtYWxpemUoKVxuXG4gICAgICAgICAgLy8gQXBwbHkgYm91bmNlIGZvcmNlIChSRVBMQUNFIHZlbG9jaXR5LCBub3QgYWRkKVxuICAgICAgICAgIHZlbG9jaXR5LnggPSBkaXJlY3Rpb24ueCAqIDAuMTVcbiAgICAgICAgICB2ZWxvY2l0eS55ID0gTWF0aC5hYnMoZGlyZWN0aW9uLnkpICogMC4xMiArIDAuMTJcbiAgICAgICAgICB2ZWxvY2l0eS56ID0gZGlyZWN0aW9uLnogKiAwLjE1XG5cbiAgICAgICAgICAvLyBQYXJ0aWNsZSBidXJzdCBvbiBjbGlja1xuICAgICAgICAgIGNyZWF0ZVBhcnRpY2xlQnVyc3QoY3ViZS5wb3NpdGlvbi54LCBjdWJlLnBvc2l0aW9uLnksIGN1YmUucG9zaXRpb24ueiwgMC44KVxuXG4gICAgICAgICAgLy8gU2NoZWR1bGUgcmV0dXJuLXRvLXBvc2l0aW9uIGFmdGVyIDEuNSBzZWNvbmRzXG4gICAgICAgICAgcmV0dXJuU3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyAxNTAwXG5cbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+agCBDdWJlIGJvdW5jZWQhIFZlbG9jaXR5OicsIHZlbG9jaXR5KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinYwgTUlTUyAtIENsaWNrIGRpZCBub3QgaGl0IGN1YmUnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHJlbmRlcmVyLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpXG4gICAgICByZW5kZXJlci5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25Nb3VzZUNsaWNrKVxuXG4gICAgICAvLyBGdW5jdGlvbiB0byBjcmVhdGUgcGFydGljbGUgYnVyc3Qgb24gaW1wYWN0XG4gICAgICBjb25zdCBjcmVhdGVQYXJ0aWNsZUJ1cnN0ID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIsIHN0cmVuZ3RoOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gcGFydGljbGVHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5IGFzIEZsb2F0MzJBcnJheVxuICAgICAgICBjb25zdCBwYXJ0aWNsZUNvdW50ID0gcG9zaXRpb25zLmxlbmd0aCAvIDNcbiAgICAgICAgY29uc3QgYnVyc3RDb3VudCA9IE1hdGgubWluKDUwLCBNYXRoLmZsb29yKHN0cmVuZ3RoICogMTAwKSlcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1cnN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IChpICUgcGFydGljbGVDb3VudCkgKiAzXG4gICAgICAgICAgcG9zaXRpb25zW2lkeF0gPSB4ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC41XG4gICAgICAgICAgcG9zaXRpb25zW2lkeCArIDFdID0geSArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuNVxuICAgICAgICAgIHBvc2l0aW9uc1tpZHggKyAyXSA9IHogKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjVcbiAgICAgICAgfVxuICAgICAgICBwYXJ0aWNsZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIEFuaW1hdGlvbiBsb29wIHdpdGggZW5oYW5jZWQgcGh5c2ljc1xuICAgICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgICAgYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHRpbWUgdG8gcmV0dXJuIHRvIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxuICAgICAgICBpZiAoIWlzUmV0dXJuaW5nVG9Qb3NpdGlvbiAmJiByZXR1cm5TdGFydFRpbWUgPiAwICYmIGN1cnJlbnRUaW1lID49IHJldHVyblN0YXJ0VGltZSkge1xuICAgICAgICAgIGlzUmV0dXJuaW5nVG9Qb3NpdGlvbiA9IHRydWVcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBTdGFydGluZyByZXR1cm4gdG8gZGVmYXVsdCBwb3NpdGlvbicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdG8gcG9zaXRpb24gbG9naWMgKGFwcGx5IGdlbnRsZSBmb3JjZSB0b3dhcmRzIGRlZmF1bHQgcG9zaXRpb24pXG4gICAgICAgIGlmIChpc1JldHVybmluZ1RvUG9zaXRpb24pIHtcbiAgICAgICAgICBjb25zdCBkeCA9IGRlZmF1bHRQb3NpdGlvbi54IC0gY3ViZS5wb3NpdGlvbi54XG4gICAgICAgICAgY29uc3QgZHkgPSBkZWZhdWx0UG9zaXRpb24ueSAtIGN1YmUucG9zaXRpb24ueVxuICAgICAgICAgIGNvbnN0IGR6ID0gZGVmYXVsdFBvc2l0aW9uLnogLSBjdWJlLnBvc2l0aW9uLnpcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopXG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAwLjIpIHtcbiAgICAgICAgICAgIC8vIENsb3NlIGVub3VnaCAtIHNuYXAgdG8gcG9zaXRpb24gYW5kIHN0b3BcbiAgICAgICAgICAgIGN1YmUucG9zaXRpb24uc2V0KGRlZmF1bHRQb3NpdGlvbi54LCBkZWZhdWx0UG9zaXRpb24ueSwgZGVmYXVsdFBvc2l0aW9uLnopXG4gICAgICAgICAgICB2ZWxvY2l0eS54ID0gMFxuICAgICAgICAgICAgdmVsb2NpdHkueSA9IDBcbiAgICAgICAgICAgIHZlbG9jaXR5LnogPSAwXG4gICAgICAgICAgICBpc1JldHVybmluZ1RvUG9zaXRpb24gPSBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuU3RhcnRUaW1lID0gMFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBDdWJlIHJldHVybmVkIHRvIGRlZmF1bHQgcG9zaXRpb24nKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBcHBseSBnZW50bGUgZm9yY2UgdG93YXJkcyBkZWZhdWx0IHBvc2l0aW9uIChpbnN0ZWFkIG9mIHNldHRpbmcgdmVsb2NpdHkgZGlyZWN0bHkpXG4gICAgICAgICAgICBjb25zdCBwdWxsU3RyZW5ndGggPSAwLjAwMlxuICAgICAgICAgICAgdmVsb2NpdHkueCArPSBkeCAqIHB1bGxTdHJlbmd0aFxuICAgICAgICAgICAgdmVsb2NpdHkueSArPSBkeSAqIHB1bGxTdHJlbmd0aFxuICAgICAgICAgICAgdmVsb2NpdHkueiArPSBkeiAqIHB1bGxTdHJlbmd0aFxuXG4gICAgICAgICAgICAvLyBEYW1wZW4gdmVsb2NpdHkgd2hpbGUgcmV0dXJuaW5nXG4gICAgICAgICAgICB2ZWxvY2l0eS54ICo9IDAuOTVcbiAgICAgICAgICAgIHZlbG9jaXR5LnkgKj0gMC45NVxuICAgICAgICAgICAgdmVsb2NpdHkueiAqPSAwLjk1XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFwcGx5IGdyYXZpdHkgd2hlbiBub3QgcmV0dXJuaW5nIHRvIHBvc2l0aW9uXG4gICAgICAgICAgdmVsb2NpdHkueSArPSBncmF2aXR5XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb24gKGtlZXAgY3ViZSBjZW50ZXJlZCBhcm91bmQgeD04KVxuICAgICAgICBjb25zdCBuZXdYID0gY3ViZS5wb3NpdGlvbi54ICsgdmVsb2NpdHkueFxuICAgICAgICBjb25zdCBuZXdZID0gY3ViZS5wb3NpdGlvbi55ICsgdmVsb2NpdHkueVxuICAgICAgICBjb25zdCBuZXdaID0gY3ViZS5wb3NpdGlvbi56ICsgdmVsb2NpdHkuelxuXG4gICAgICAgIGN1YmUucG9zaXRpb24ueCA9IG5ld1hcbiAgICAgICAgY3ViZS5wb3NpdGlvbi55ID0gbmV3WVxuICAgICAgICBjdWJlLnBvc2l0aW9uLnogPSBuZXdaXG5cbiAgICAgICAgLy8gRHluYW1pYyByb3RhdGlvbiBiYXNlZCBvbiB2ZWxvY2l0eSAobW9yZSByZWFsaXN0aWMgcGh5c2ljcylcbiAgICAgICAgY29uc3Qgc3BlZWQgPSBNYXRoLnNxcnQodmVsb2NpdHkueCAqKiAyICsgdmVsb2NpdHkueSAqKiAyICsgdmVsb2NpdHkueiAqKiAyKVxuICAgICAgICBjdWJlLnJvdGF0aW9uLnggKz0gMC4wMDYgKyBzcGVlZCAqIDAuNVxuICAgICAgICBjdWJlLnJvdGF0aW9uLnkgKz0gMC4wMDggKyBzcGVlZCAqIDAuNlxuICAgICAgICBjdWJlLnJvdGF0aW9uLnogKz0gMC4wMDUgKyBzcGVlZCAqIDAuNFxuXG4gICAgICAgIC8vIFVwZGF0ZSBwYXJ0aWNsZSBwb3NpdGlvbnMgKGZhZGUgb3V0KVxuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBwYXJ0aWNsZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkgYXMgRmxvYXQzMkFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgcG9zaXRpb25zW2kgKyAxXSAtPSAwLjAyIC8vIFBhcnRpY2xlcyBmYWxsXG4gICAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMV0gPCAtMTUpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uc1tpICsgMV0gPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnRpY2xlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWVcblxuICAgICAgICAvLyBDaGVjayBmbG9vciBjb2xsaXNpb25cbiAgICAgICAgLy8gQ3ViZSBpcyAzIHVuaXRzIHRhbGwsIHNvIHJhZGl1cyBpcyAxLjUuIEZsb29yIGlzIGF0IHk9LTRcbiAgICAgICAgLy8gQ3ViZSBib3R0b20gPSBjdWJlLnBvc2l0aW9uLnkgLSAxLjVcbiAgICAgICAgY29uc3QgaGFsZlNpemUgPSAxLjVcbiAgICAgICAgY29uc3QgeEEgPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKS5hcHBseVF1YXRlcm5pb24oY3ViZS5xdWF0ZXJuaW9uKVxuY29uc3QgeUEgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKS5hcHBseVF1YXRlcm5pb24oY3ViZS5xdWF0ZXJuaW9uKVxuY29uc3QgekEgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKS5hcHBseVF1YXRlcm5pb24oY3ViZS5xdWF0ZXJuaW9uKVxuY29uc3QgdmVydEV4dGVudCA9IGhhbGZTaXplICogKE1hdGguYWJzKHhBLnkpICsgTWF0aC5hYnMoeUEueSkgKyBNYXRoLmFicyh6QS55KSlcbmNvbnN0IGN1YmVCb3R0b20gPSBjdWJlLnBvc2l0aW9uLnkgLSB2ZXJ0RXh0ZW50XG4gICAgICAgIGNvbnN0IGZsb29yWSA9IC00XG5cbiAgICAgICAgaWYgKGN1YmVCb3R0b20gPD0gZmxvb3JZKSB7XG4gICAgICAgICAgY3ViZS5wb3NpdGlvbi55ID0gZmxvb3JZICsgdmVydEV4dGVudCAgLy8gS2VlcCBjdWJlIHNpdHRpbmcgb24gZmxvb3IgKG9yaWVudGF0aW9uLWF3YXJlKVxuICAgICAgICAgIHZlbG9jaXR5LnkgPSAtdmVsb2NpdHkueSAqIGJvdW5jZVxuICAgICAgICAgIHZlbG9jaXR5LnggKj0gZnJpY3Rpb24gIC8vIEFwcGx5IGZyaWN0aW9uXG4gICAgICAgICAgdmVsb2NpdHkueiAqPSBmcmljdGlvblxuXG4gICAgICAgICAgLy8gQ3JlYXRlIHJpcHBsZSBhbmQgcGFydGljbGUgYnVyc3Qgb24gZmxvb3IgaW1wYWN0IChhZGp1c3QgZm9yIGZsb29yIG9mZnNldClcbiAgICAgICAgICBpZiAoTWF0aC5hYnModmVsb2NpdHkueSkgPiAwLjAwMykge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBwcmVjaXNlIGNvbnRhY3QgcG9pbnQgKHdvcmxkLXNwYWNlKSBieSBzYW1wbGluZyB0aGUgbG93ZXN0IGN1YmUgdmVydGV4XG5jb25zdCBocyA9IGhhbGZTaXplXG5sZXQgbWluWSA9IEluZmluaXR5XG5sZXQgc3VtWCA9IDAsIHN1bVogPSAwLCBjb3VudCA9IDBcbmNvbnN0IG94ID0gW2hzLCBocywgaHMsIGhzLCAtaHMsIC1ocywgLWhzLCAtaHNdXG5jb25zdCBveSA9IFtocywgaHMsIC1ocywgLWhzLCBocywgaHMsIC1ocywgLWhzXVxuY29uc3Qgb3ogPSBbaHMsIC1ocywgaHMsIC1ocywgaHMsIC1ocywgaHMsIC1oc11cbmZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gIGNvbnN0IHd4ID0gY3ViZS5wb3NpdGlvbi54ICsgeEEueCAqIG94W2ldICsgeUEueCAqIG95W2ldICsgekEueCAqIG96W2ldXG4gIGNvbnN0IHd5ID0gY3ViZS5wb3NpdGlvbi55ICsgeEEueSAqIG94W2ldICsgeUEueSAqIG95W2ldICsgekEueSAqIG96W2ldXG4gIGNvbnN0IHd6ID0gY3ViZS5wb3NpdGlvbi56ICsgeEEueiAqIG94W2ldICsgeUEueiAqIG95W2ldICsgekEueiAqIG96W2ldXG4gIGlmICh3eSA8IG1pblkgLSAxZS02KSB7IG1pblkgPSB3eTsgc3VtWCA9IHd4OyBzdW1aID0gd3o7IGNvdW50ID0gMSB9XG4gIGVsc2UgaWYgKE1hdGguYWJzKHd5IC0gbWluWSkgPD0gMWUtNikgeyBzdW1YICs9IHd4OyBzdW1aICs9IHd6OyBjb3VudCsrIH1cbn1cbmNvbnN0IGNvbnRhY3RYV29ybGQgPSBzdW1YIC8gY291bnRcbmNvbnN0IGNvbnRhY3RaV29ybGQgPSBzdW1aIC8gY291bnRcbmNyZWF0ZVJpcHBsZShjb250YWN0WFdvcmxkIC0gZmxvb3IucG9zaXRpb24ueCwgY29udGFjdFpXb3JsZCwgTWF0aC5taW4oMS4yLCBNYXRoLmFicyh2ZWxvY2l0eS55KSAqIDEuMikpICAvLyBDZW50ZXJlZCBvbiBhY3R1YWwgY29udGFjdCBwb2ludCAoY29udmVydGVkIHRvIGZsb29yIGxvY2FsKVxuICAgICAgICAgICAgY3JlYXRlUGFydGljbGVCdXJzdChjdWJlLnBvc2l0aW9uLngsIGN1YmUucG9zaXRpb24ueSwgY3ViZS5wb3NpdGlvbi56LCBNYXRoLmFicyh2ZWxvY2l0eS55KSlcbiAgICAgICAgICAgIHB1bHNlRmxvb3JHbG93KE1hdGguYWJzKHZlbG9jaXR5LnkpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldHRsZSB0aGUgY3ViZSBpZiB2ZWxvY2l0eSBpcyB2ZXJ5IGxvd1xuICAgICAgICAgIGNvbnN0IHRvdGFsVmVsb2NpdHkgPSBNYXRoLnNxcnQodmVsb2NpdHkueCAqKiAyICsgdmVsb2NpdHkueSAqKiAyICsgdmVsb2NpdHkueiAqKiAyKVxuICAgICAgICAgIGlmICh0b3RhbFZlbG9jaXR5IDwgMC4wMDUpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5LnggPSAwXG4gICAgICAgICAgICB2ZWxvY2l0eS55ID0gMFxuICAgICAgICAgICAgdmVsb2NpdHkueiA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBjZWlsaW5nIGNvbGxpc2lvbiAoc29saWQgY2VpbGluZylcbiAgICAgICAgY29uc3QgY2VpbGluZ1kgPSBib3VuZHMueVxuICAgICAgICBpZiAoY3ViZS5wb3NpdGlvbi55ICsgdmVydEV4dGVudCA+PSBjZWlsaW5nWSkge1xuICAgICAgICAgIGN1YmUucG9zaXRpb24ueSA9IGNlaWxpbmdZIC0gdmVydEV4dGVudFxuICAgICAgICAgIHZlbG9jaXR5LnkgPSAtdmVsb2NpdHkueSAqIGJvdW5jZVxuXG4gICAgICAgICAgLy8gTm8gcmlwcGxlcyBvbiBjZWlsaW5nIGhpdHM7IG9wdGlvbmFsIHBhcnRpY2xlIGJ1cnN0IG9ubHlcbiAgICAgICAgICBjcmVhdGVQYXJ0aWNsZUJ1cnN0KGN1YmUucG9zaXRpb24ueCwgY3ViZS5wb3NpdGlvbi55LCBjdWJlLnBvc2l0aW9uLnosIE1hdGguYWJzKHZlbG9jaXR5LnkpICogMC41KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgd2FsbCBjb2xsaXNpb25zIChYIGF4aXMpXG4gICAgICAgIGNvbnN0IG1pblggPSA4IC0gYm91bmRzLnggKyBoYWxmU2l6ZVxuICAgICAgICBjb25zdCBtYXhYID0gOCArIGJvdW5kcy54IC0gaGFsZlNpemVcbiAgICAgICAgaWYgKGN1YmUucG9zaXRpb24ueCA8PSBtaW5YIHx8IGN1YmUucG9zaXRpb24ueCA+PSBtYXhYKSB7XG4gICAgICAgICAgY3ViZS5wb3NpdGlvbi54ID0gY3ViZS5wb3NpdGlvbi54IDw9IG1pblggPyBtaW5YIDogbWF4WFxuICAgICAgICAgIHZlbG9jaXR5LnggPSAtdmVsb2NpdHkueCAqIGJvdW5jZVxuXG4gICAgICAgICAgLy8gTm8gcmlwcGxlcyBvbiB3YWxsIGltcGFjdDsgcGFydGljbGUgYnVyc3Qgb25seVxuICAgICAgICAgIGNyZWF0ZVBhcnRpY2xlQnVyc3QoY3ViZS5wb3NpdGlvbi54LCBjdWJlLnBvc2l0aW9uLnksIGN1YmUucG9zaXRpb24ueiwgTWF0aC5hYnModmVsb2NpdHkueCkgKiAwLjcpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayB3YWxsIGNvbGxpc2lvbnMgKFogYXhpcylcbiAgICAgICAgY29uc3QgbWluWiA9IC1ib3VuZHMueiArIGhhbGZTaXplXG4gICAgICAgIGNvbnN0IG1heFogPSBib3VuZHMueiAtIGhhbGZTaXplXG4gICAgICAgIGlmIChjdWJlLnBvc2l0aW9uLnogPD0gbWluWiB8fCBjdWJlLnBvc2l0aW9uLnogPj0gbWF4Wikge1xuICAgICAgICAgIGN1YmUucG9zaXRpb24ueiA9IGN1YmUucG9zaXRpb24ueiA8PSBtaW5aID8gbWluWiA6IG1heFpcbiAgICAgICAgICB2ZWxvY2l0eS56ID0gLXZlbG9jaXR5LnogKiBib3VuY2VcblxuICAgICAgICAgIC8vIE5vIHJpcHBsZXMgb24gd2FsbCBpbXBhY3Q7IHBhcnRpY2xlIGJ1cnN0IG9ubHlcbiAgICAgICAgICBjcmVhdGVQYXJ0aWNsZUJ1cnN0KGN1YmUucG9zaXRpb24ueCwgY3ViZS5wb3NpdGlvbi55LCBjdWJlLnBvc2l0aW9uLnosIE1hdGguYWJzKHZlbG9jaXR5LnopICogMC43KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGZsb29yIHJpcHBsZXMgKHJldmVhbHMgY2lyY3VpdCBib2FyZClcbiAgICAgICAgdXBkYXRlRmxvb3JSaXBwbGVzKClcblxuICAgICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSlcbiAgICAgIH1cblxuICAgICAgYW5pbWF0ZSgpXG5cbiAgICAgIC8vIEhhbmRsZSByZXNpemVcbiAgICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgICAgIGNvbnN0IGN3ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGhcbiAgICAgICAgY29uc3QgY2ggPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjdyA+IDEwID8gY3cgOiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IDYwMClcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY2ggPiAxMCA/IGNoIDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmlubmVySGVpZ2h0IDogNjAwKVxuICAgICAgICBjYW1lcmEuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHRcbiAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpXG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpXG4gICAgICAgIHJlbmRlcmVyLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpXG4gICAgICAgIHJlbmRlcmVyLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbk1vdXNlQ2xpY2spXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkKVxuXG4gICAgICAgIGlmIChyZW5kZXJlciAmJiBjb250YWluZXJSZWYuY3VycmVudD8uY29udGFpbnMocmVuZGVyZXIuZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICBjb250YWluZXJSZWYuY3VycmVudC5yZW1vdmVDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyPy5kaXNwb3NlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0KClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoYW5pbWF0aW9uSWQpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICByZWY9e2NvbnRhaW5lclJlZn1cbiAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIlxuICAgICAgc3R5bGU9e3sgbWluSGVpZ2h0OiAnMTAwdmgnLCBjdXJzb3I6ICdwb2ludGVyJyB9fVxuICAgIC8+XG4gIClcbn1cblxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIlRIUkVFIiwiUnViaWtzQ3ViZSIsImNvbnRhaW5lclJlZiIsImN1cnJlbnQiLCJzY2VuZSIsImNhbWVyYSIsInJlbmRlcmVyIiwiY3ViZSIsImFuaW1hdGlvbklkIiwiZmxvb3IiLCJmbG9vckdlb21ldHJ5IiwibW91c2UiLCJ4IiwieSIsInJheWNhc3RlciIsIm1vdXNlVmVjdG9yIiwicGFydGljbGVzIiwicGFydGljbGVTeXN0ZW0iLCJ0cmFpbFBvc2l0aW9ucyIsInZlbG9jaXR5IiwieiIsImdyYXZpdHkiLCJib3VuY2UiLCJmcmljdGlvbiIsImJvdW5kcyIsImRlZmF1bHRQb3NpdGlvbiIsInJpcHBsZXMiLCJsYXN0Q2xpY2tUaW1lIiwibGFzdFJpcHBsZVRpbWUiLCJnc2FwUmVmIiwiZmxvb3JNYXRlcmlhbCIsImlzUmV0dXJuaW5nVG9Qb3NpdGlvbiIsInJldHVyblN0YXJ0VGltZSIsInJpcHBsZVBhcmFtcyIsIm1heFJhZGl1cyIsImV4cGFuc2lvblNwZWVkIiwid2F2ZUhlaWdodCIsInJpbmdXaWR0aCIsImVtaXNzaXZlR2FpbiIsImhpZ2hsaWdodEdhaW4iLCJncmlkU2NhbGUiLCJ0cmFjZUJvb3N0IiwiYWZ0ZXJnbG93RGVjYXkiLCJub2lzZVNjYWxlIiwibm9pc2VTY3JvbGxTcGVlZCIsImluaXQiLCJjb250YWluZXIiLCJjdyIsImNoIiwid2lkdGgiLCJoZWlnaHQiLCJvZmZzZXRzIiwiZ2FwIiwiaW5kZXgiLCJnZW9tZXRyeSIsImlzVGV4dHVyZWQiLCJzdXJmYWNlVHlwZSIsIm1hdGVyaWFsIiwiY3ViZWxldCIsImVkZ2VzIiwibGluZSIsImhpdFNwaGVyZUdlb21ldHJ5IiwiaGl0U3BoZXJlTWF0ZXJpYWwiLCJoaXRTcGhlcmUiLCJmbG9vclNpemUiLCJmbG9vclNlZ21lbnRzIiwiYW1iaWVudExpZ2h0IiwiZGlyZWN0aW9uYWxMaWdodDEiLCJkaXJlY3Rpb25hbExpZ2h0MiIsInBvaW50TGlnaHQxIiwicG9pbnRMaWdodDIiLCJyaW1MaWdodDEiLCJsb2FkR1NBUCIsImUiLCJwdWxzZUZsb29yR2xvdyIsInJpbUxpZ2h0MiIsInBhcnRpY2xlQ291bnQiLCJwYXJ0aWNsZUdlb21ldHJ5IiwicG9zaXRpb25zIiwiY29sb3JzIiwic2l6ZXMiLCJpIiwicGFydGljbGVNYXRlcmlhbCIsImNyZWF0ZVJpcHBsZSIsInVwZGF0ZUZsb29yUmlwcGxlcyIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUNsaWNrIiwiY3JlYXRlUGFydGljbGVCdXJzdCIsImFuaW1hdGUiLCJoYW5kbGVSZXNpemUiLCJTY2VuZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJwb3NpdGlvbiIsInNldCIsImxvb2tBdCIsIlJheWNhc3RlciIsIlZlY3RvcjIiLCJXZWJHTFJlbmRlcmVyIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJzZXRQaXhlbFJhdGlvIiwiTWF0aCIsIm1pbiIsImRldmljZVBpeGVsUmF0aW8iLCJzZXRTaXplIiwic2hhZG93TWFwIiwiZW5hYmxlZCIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsIkdyb3VwIiwiQm94R2VvbWV0cnkiLCJyYW5kb20iLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsImNvbG9yIiwibWV0YWxuZXNzIiwicm91Z2huZXNzIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwiZW1pc3NpdmUiLCJlbWlzc2l2ZUludGVuc2l0eSIsIk1lc2giLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsIkVkZ2VzR2VvbWV0cnkiLCJMaW5lU2VnbWVudHMiLCJMaW5lQmFzaWNNYXRlcmlhbCIsImFkZCIsInRyYXZlcnNlIiwibyIsInJlbmRlck9yZGVyIiwiU3BoZXJlR2VvbWV0cnkiLCJNZXNoQmFzaWNNYXRlcmlhbCIsInZpc2libGUiLCJuYW1lIiwiY29uc29sZSIsImxvZyIsIlBsYW5lR2VvbWV0cnkiLCJyb3RhdGVYIiwiUEkiLCJTaGFkZXJNYXRlcmlhbCIsInVuaWZvcm1zIiwidGltZSIsInZhbHVlIiwiYmFzZUNvbG9yIiwiQ29sb3IiLCJncmlkQ29sb3IiLCJnbG93Q29sb3IiLCJyaXBwbGVQb3NpdGlvbnMiLCJWZWN0b3IzIiwicmlwcGxlUmFkaWkiLCJyaXBwbGVTdHJlbmd0aHMiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsInNpZGUiLCJEb3VibGVTaWRlIiwiQW1iaWVudExpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodCIsIlBvaW50TGlnaHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImdzYXAiLCJzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiYXN5bmMiLCJvbmxvYWQiLCJvbmVycm9yIiwiaGVhZCIsImZyb21UbyIsImR1cmF0aW9uIiwiZWFzZSIsInN0cmVuZ3RoIiwidGFyZ2V0SW50ZW5zaXR5IiwidG8iLCJ5b3lvIiwicmVwZWF0IiwiQnVmZmVyR2VvbWV0cnkiLCJGbG9hdDMyQXJyYXkiLCJzZXRBdHRyaWJ1dGUiLCJCdWZmZXJBdHRyaWJ1dGUiLCJQb2ludHNNYXRlcmlhbCIsInNpemUiLCJ2ZXJ0ZXhDb2xvcnMiLCJibGVuZGluZyIsIkFkZGl0aXZlQmxlbmRpbmciLCJzaXplQXR0ZW51YXRpb24iLCJQb2ludHMiLCJub3ciLCJwZXJmb3JtYW5jZSIsIkRhdGUiLCJ3b3JsZFgiLCJ3b3JsZFoiLCJ3b3JsZFkiLCJyaW5ncyIsIndhdmVHZW8iLCJUb3J1c0dlb21ldHJ5Iiwid2F2ZU1hdCIsIndhdmUiLCJyb3RhdGlvbiIsInB1c2giLCJtZXNoIiwidHlwZSIsImluaXRpYWxZIiwibGVuZ3RoIiwicmVtb3ZlZCIsInNoaWZ0IiwiZm9yRWFjaCIsInIiLCJyZW1vdmUiLCJwIiwic3lzdGVtIiwicmFkaWkiLCJzdHJlbmd0aHMiLCJmaWx0ZXIiLCJyaXBwbGUiLCJjdXJyZW50UmFkaXVzIiwidG90YWxEdXJhdGlvbiIsInByb2dyZXNzIiwiZWFzZU91dCIsInBvdyIsInJpbmdPYmoiLCJyaW5nIiwic2NhbGUiLCJoZWlnaHRPZmZzZXQiLCJtYXgiLCJldmVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwibGVmdCIsImNsaWVudFkiLCJ0b3AiLCJzZXRGcm9tQ2FtZXJhIiwiaW50ZXJzZWN0cyIsImludGVyc2VjdE9iamVjdCIsInN0eWxlIiwiY3Vyc29yIiwiY3VycmVudFRpbWUiLCJwb2ludCIsImRpcmVjdGlvbiIsImNsaWNrUG9pbnQiLCJzdWJWZWN0b3JzIiwibm9ybWFsaXplIiwiYWJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dHJpYnV0ZXMiLCJhcnJheSIsImJ1cnN0Q291bnQiLCJpZHgiLCJuZWVkc1VwZGF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImR4IiwiZHkiLCJkeiIsImRpc3RhbmNlIiwic3FydCIsInB1bGxTdHJlbmd0aCIsIm5ld1giLCJuZXdZIiwibmV3WiIsInNwZWVkIiwiaGFsZlNpemUiLCJ4QSIsImFwcGx5UXVhdGVybmlvbiIsInF1YXRlcm5pb24iLCJ5QSIsInpBIiwidmVydEV4dGVudCIsImN1YmVCb3R0b20iLCJmbG9vclkiLCJocyIsIm1pblkiLCJJbmZpbml0eSIsInN1bVgiLCJzdW1aIiwiY291bnQiLCJveCIsIm95Iiwib3oiLCJ3eCIsInd5Iiwid3oiLCJjb250YWN0WFdvcmxkIiwiY29udGFjdFpXb3JsZCIsInRvdGFsVmVsb2NpdHkiLCJjZWlsaW5nWSIsIm1pblgiLCJtYXhYIiwibWluWiIsIm1heFoiLCJyZW5kZXIiLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY29udGFpbnMiLCJyZW1vdmVDaGlsZCIsImRpc3Bvc2UiLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiLCJtaW5IZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/layout/RubiksCube.tsx\n"));

/***/ })

});